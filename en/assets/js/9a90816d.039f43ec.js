(self.webpackChunkalaya_docs=self.webpackChunkalaya_docs||[]).push([[5677],{3905:function(e,t,a){"use strict";a.d(t,{Zo:function(){return m},kt:function(){return c}});var n=a(7294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function p(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var o=n.createContext({}),s=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},m=function(e){var t=s(e.components);return n.createElement(o.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,r=e.originalType,o=e.parentName,m=p(e,["components","mdxType","originalType","parentName"]),u=s(a),c=l,k=u["".concat(o,".").concat(c)]||u[c]||d[c]||r;return a?n.createElement(k,i(i({ref:t},m),{},{components:a})):n.createElement(k,i({ref:t},m))}));function c(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=a.length,i=new Array(r);i[0]=u;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p.mdxType="string"==typeof e?e:l,i[1]=p;for(var s=2;s<r;s++)i[s]=a[s];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},3754:function(e,t,a){"use strict";a.r(t),a.d(t,{frontMatter:function(){return i},contentTitle:function(){return p},metadata:function(){return o},toc:function(){return s},default:function(){return d}});var n=a(2122),l=a(9756),r=(a(7294),a(3905)),i={id:"WASM_Smart_Contract",title:"WASM Smart Contract",sidebar_label:"WASM Smart Contract"},p=void 0,o={unversionedId:"WASM_Smart_Contract",id:"WASM_Smart_Contract",isDocsHomePage:!1,title:"WASM Smart Contract",description:"WebAssembly (wasm for short) is a binary instruction set designed for stacked virtual machines. Wasm was designed to be a compile target for platforms such as C / C ++ / Rust, and was originally designed to solve JavaScript performance issues. Wasm is a web standard being led by the W3C and supported by browser vendors such as Google, Microsoft, and Mozilla.",source:"@site/docs/WASM_Smart_Contract.md",sourceDirName:".",slug:"/WASM_Smart_Contract",permalink:"/alaya-devdocs/en/WASM_Smart_Contract",editUrl:"https://github.com/AlayaNetwork/alaya-devdocs/tree/main/website/docs/WASM_Smart_Contract.md",version:"current",frontMatter:{id:"WASM_Smart_Contract",title:"WASM Smart Contract",sidebar_label:"WASM Smart Contract"}},s=[{value:"Getting Started",id:"getting-started",children:[{value:"Introduction",id:"introduction",children:[]},{value:"alaya-truffle Introduction",id:"alaya-truffle-introduction",children:[]},{value:"Create HelloWorld Contract",id:"create-helloworld-contract",children:[]},{value:"Compile HelloWorld Contract",id:"compile-helloworld-contract",children:[]},{value:"Deploly HelloWorld Contract",id:"deploly-helloworld-contract",children:[]},{value:"Call HelloWorld Contract",id:"call-helloworld-contract",children:[]}]},{value:"Development Costs",id:"development-costs",children:[{value:"Summary",id:"summary",children:[]},{value:"Small-sized Contract",id:"small-sized-contract",children:[]},{value:"Medium-sized Contract",id:"medium-sized-contract",children:[]},{value:"Large-sized Contract",id:"large-sized-contract",children:[]}]},{value:"Best Practice",id:"best-practice",children:[{value:"Introduction",id:"introduction-1",children:[]},{value:"Reasonable Cost Setting",id:"reasonable-cost-setting",children:[]},{value:"Avoid Timeouts",id:"avoid-timeouts",children:[]},{value:"Punishment For Illegal Operations",id:"punishment-for-illegal-operations",children:[]},{value:"C/C++ Language Limit",id:"cc-language-limit",children:[]},{value:"Coding Standards",id:"coding-standards",children:[]}]},{value:"API",id:"api",children:[{value:"block api",id:"block-api",children:[]},{value:"transaction api",id:"transaction-api",children:[]},{value:"account api",id:"account-api",children:[]},{value:"storage api",id:"storage-api",children:[]},{value:"contract api",id:"contract-api",children:[]},{value:"exception api",id:"exception-api",children:[]},{value:"other api",id:"other-api",children:[]}]},{value:"FAQ",id:"faq",children:[{value:"About Compile",id:"about-compile",children:[]},{value:"About Contract",id:"about-contract",children:[]}]}],m={toc:s};function d(e){var t=e.components,a=(0,l.Z)(e,["components"]);return(0,r.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"WebAssembly (wasm for short) is a binary instruction set designed for stacked virtual machines. Wasm was designed to be a compile target for platforms such as C / C ++ / Rust, and was originally designed to solve JavaScript performance issues. Wasm is a web standard being led by the W3C and supported by browser vendors such as Google, Microsoft, and Mozilla."),(0,r.kt)("p",null,"This tutorial is mainly to guide users to create a WASM smart contract using wasm language on Alaya."),(0,r.kt)("p",null,"It is mainly explained from the following aspects\uff1a"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#getting-started"},"Getting Started")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#development-costs"},"Development Costs")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#best-practice"},"Best Practice")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#api"},"API")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#faq"},"FAQ"))),(0,r.kt)("h2",{id:"getting-started"},"Getting Started"),(0,r.kt)("h3",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"This tutorial is mainly to guide users to create a simple HelloWorld smart contract using wasm language on Alaya, compile, deploy, and call this contract through alaya-truffle.If you want to use a richer API."),(0,r.kt)("h3",{id:"alaya-truffle-introduction"},"alaya-truffle Introduction"),(0,r.kt)("p",null,"alaya-truffle is a tool provided by Alaya that can compile, deploy, and invoke smart contracts locally. For specific installation and usage manuals, refer to:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"alaya-truffle develop tools ",(0,r.kt)("a",{parentName:"li",href:"https://platon-truffle.readthedocs.io/en/alaya/getting-started/installation.html"},"specific installation")),(0,r.kt)("li",{parentName:"ul"},"alaya-truffle develop tools ",(0,r.kt)("a",{parentName:"li",href:"https://platon-truffle.readthedocs.io/en/alaya/"},"usage manuals"))),(0,r.kt)("h3",{id:"create-helloworld-contract"},"Create HelloWorld Contract"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},'#include <platon/platon.hpp>\n#include <string>\nusing namespace platon;\n\nclass message {\n   public:\n      std::string head;\n      PLATON_SERIALIZE(message, (head))\n};\n\nclass my_message : public message {\n   public:\n      std::string body;\n      std::string end;\n      PLATON_SERIALIZE_DERIVED(my_message, message, (body)(end))\n};\n\nCONTRACT HelloWorld : public platon::Contract{\n   public:\n      ACTION void init(const my_message &one_message){\n        info.self().push_back(one_message);\n      }\n\n      ACTION void add_message(const my_message &one_message){\n          info.self().push_back(one_message);\n      }\n\n      CONST uint8_t get_message_size(){\n          return info.self().size();\n      }\n\n      CONST std::string get_message_body(const uint8_t index){\n          return info.self()[index].body;\n      }\n\n   private:\n      platon::StorageType<"myvector"_n, std::vector<my_message>> info;\n};\n\nPLATON_DISPATCH(HelloWorld, (init)(add_message)(get_message_size)(get_message_body))\n\n')),(0,r.kt)("p",null,"Contract Files Description:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Each contract file has only one contract class. The contract class is decorated with Contract. It must be publicly inherited from platon :: Contract and must have an init function.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"ACTION and CONST qualified member functions represent callable functions, and such member functions cannot be overloaded. The ACTION function will modify the data on the chain. The CONST function just queries the attributes and does not modify the data on the chain.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The type in the callable function parameter list is a custom type. In this type definition, you need to add the PLATON_SERIALIZE macro to declare the serialization function. This type inherits from other types. You need to add the PLATON_SERIALIZE_DERIVED macro to declare the serialization function.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Callable functions can only be called externally if the unified entry function is defined in the PLATON_DISPATCH macro.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"At present, platon will persistently store member variables of the contract class. The member variables must be of type platon :: StorageType. The first parameter string of the platon :: StorageType template is followed by ","_","n, and the string must be .12345abcdefghijklmnopqrstuvwxyz. 32 characters Characters. The second parameter is the concrete type of the actual storage. Member function modification member variables need to obtain an instance of a specific type through the self () function, and then execute the corresponding instance function.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The second parameter type of the platon :: StorageType template is a custom type. A PLATON_SERIALIZE macro must be added to this type definition to declare a serialization function. This type inherits from other types. A PLATON_SERIALIZE_DERIVED macro must be added to declare a serialization function."))),(0,r.kt)("h3",{id:"compile-helloworld-contract"},"Compile HelloWorld Contract"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step1.")," Creat new directory for HelloWorld project"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mkdir HelloWorld && cd HelloWorld\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The following commands are performed in the HelloWorld directory without special instructions")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step2.")," Init project"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"alaya-truffle init\n")),(0,r.kt)("p",null,"After the command is executed, project directory structure is as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"contracts/")," wasm contract directory")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"migrations/")," depoly file directory")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"test/")," test script directory")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"truffle-config.js")," alaya-truffle config"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step3.")," Move HelloWorld contract compiled in to HelloWorld/contracts/"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ls contracts/\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"HelloWorld.cpp")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step4.")," Modify the alaya-truffle configuration file truffle-config.js and add the compiled wasm contract version number"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"vim truffle-config.js\n")),(0,r.kt)("p",null,"Truffle-config.js content is as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'compilers: {\n     wasm: {\n           version: "1.0.0"\n     }\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step5.")," Compile contract"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"alaya-truffle compile\n")),(0,r.kt)("p",null,"After the command is executed, project directory structure is as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"build/")," wasm contract directory after compiled"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"build/contracts/HelloWorld.abi.json")," HelloWorld contract compiled abi interface file"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"build/contracts/HelloWorld.wasm")," HelloWorld contract compiled binary")),(0,r.kt)("h3",{id:"deploly-helloworld-contract"},"Deploly HelloWorld Contract"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step1.")," Setting config information for blockchain in truffle-config.js"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"vim truffle-config.js\n")),(0,r.kt)("p",null,"Set blockchain network info"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'networks: {\n    development: {\n       host: "10.1.1.6",     // blockchain server address\n       port: 8806,            // server port\n       network_id: "*",       // Any network (default: none)\n       from: "atp1jtfqqqr6436ppj6ccnrh8xjg7qals3ctnnmurp",\n       gas: 999999,\n       gasPrice: 1000000000,\n    },\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"step2.")," Unlock wallet account"),(0,r.kt)("p",null,"Enter the alaya-truffle console"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"alaya-truffle console\n")),(0,r.kt)("p",null,"Import the private key (you can skip this step if you have already imported it)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'web3.platon.personal.importRawKey("Your wallet private key","Your wallet password");\n')),(0,r.kt)("p",null,"Successful import will see the address corresponding to the private key as follows\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"'atp1jtfqqqr6436ppj6ccnrh8xjg7qals3ctnnmurp'\n")),(0,r.kt)("p",null,"Unlock wallet account"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"}," web3.platon.personal.unlockAccount('Your wallet address','Your wallet password',999999);\n")),(0,r.kt)("p",null,"After unlocking successfully, you will see the following information\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ture\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step3.")," Deploy contract"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'alaya-truffle deploy --wasm --contract-name HelloWorld --params \'[[["1"], "2", "3"]]\'\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"HelloWorld")," deployed contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"params")," parameters of contract init function")),(0,r.kt)("p",null,"If deploying successfully\uff0cyou will see log info as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"receipt:  { blockHash:\n   '0x266733b693ba650315a59c34e72804c06ca3e27fab145625797bd42259b572c5',\n  blockNumber: 70441,\n  contractAddress: 'atp12ts3s0zd7s8hm2vwv8wxe3rpvrwpv6tpsx8shx',\n  cumulativeGasUsed: 291314,\n  from: 'atp1jtfqqqr6436ppj6ccnrh8xjg7qals3ctnnmurp',\n  gasUsed: 291314,\n  logs: [],\n  logsBloom:\n   '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',\n  status: true,\n  to: null,\n  transactionHash:\n   '0x60946ebf0ccddc76a0234353435de73e7901888227fb2f03922fb0ce265a4e9d',\n  transactionIndex: 0 }\n  contract HelloWorld deployed successfully\n======================\n\n   > transactionHash:     0x60946ebf0ccddc76a0234353435de73e7901888227fb2f03922fb0ce265a4e9d\n   > contract address:    atp12ts3s0zd7s8hm2vwv8wxe3rpvrwpv6tpsx8shx\n   > block number:        70441\n   > block timestamp:     1583247148341\n   > account:             atp1jtfqqqr6436ppj6ccnrh8xjg7qals3ctnnmurp\n   > balance:             3533694129556768659166595001485837031654967793751237866225582808584074296\n   > gas limit:           100000000\n   > gas used:            291314\n   > gas price:           0.000000050000000004 ATP\n   > total cost:          0.014565700001165256 ATP\n")),(0,r.kt)("h3",{id:"call-helloworld-contract"},"Call HelloWorld Contract"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step1.")," Enter the alaya-truffle console"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"alaya-truffle console\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"You can execute command in alaya-truffle console")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step2.")," Create contract object"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'var abi = [{"baseclass":[],"fields":[{"name":"head","type":"string"}],"name":"message","type":"struct"},{"baseclass":["message"],"fields":[{"name":"body","type":"string"},{"name":"end","type":"string"}],"name":"my_message","type":"struct"},{"constant":false,"input":[{"name":"one_message","type":"my_message"}],"name":"init","output":"void","type":"Action"},{"constant":false,"input":[{"name":"one_message","type":"my_message"}],"name":"add_message","output":"void","type":"Action"},{"constant":true,"input":[],"name":"get_message_size","output":"uint8","type":"Action"},{"constant":true,"input":[{"name":"index","type":"uint8"}],"name":"get_message_body","output":"string","type":"Action"}];\nvar contractAddr = \'atp12ts3s0zd7s8hm2vwv8wxe3rpvrwpv6tpsx8shx\';\n\nvar helloworld = new web3.platon.Contract(abi,contractAddr,{vmType: 1 });\n')),(0,r.kt)("p",null,"Description\uff1a"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"abi")," the interface provided by the contract to external calls\uff0cthe abi in the file compiled \uff1a",(0,r.kt)("inlineCode",{parentName:"li"},"HelloWorld/build/contracts/HelloWorld.json")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"contractAddr")," contract address"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"helloWorld")," contract object created")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step3.")," Call contract"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"helloworld.methods\n  .add_message('[[[\"5\"], \"6\", \"7\"]]')\n  .send({\n    from: 'atp1jtfqqqr6436ppj6ccnrh8xjg7qals3ctnnmurp',\n    gas: 999999\n  })\n  .on('receipt', function (receipt) {\n    console.log(receipt)\n  })\n  .on('error', console.error)\n")),(0,r.kt)("p",null,"Description\uff1a"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"helloWorld")," the contract object created"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"methods")," specify the call method"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"add_message")," method in the HelloWorld contract with a custom my_message input"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"from")," caller's wallet address"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"on")," listen to the result of the contract method executed. If failed, it will print the error info. If succeeded, the console will print the receipt as belows:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"{ blockHash:\n   '0x669c7b8cb938cc30845e08dc4ceda08f2e17207c267ade97dc5458b445405736',\n  blockNumber: 74665,\n  contractAddress: null,\n  cumulativeGasUsed: 108549,\n  from: 'atp1jtfqqqr6436ppj6ccnrh8xjg7qals3ctnnmurp',\n  gasUsed: 108549,\n  logsBloom:\n   '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',\n  status: true,\n  to: 'atp12ts3s0zd7s8hm2vwv8wxe3rpvrwpv6tpsx8shx',\n  transactionHash:\n   '0x2b5e590df7e70ad428b1ccb06bda5dcce47f84c4d981c2fb475aca9ec9d0000a',\n  transactionIndex: 0,\n  events: {} }\n{ blockHash:\n   '0x669c7b8cb938cc30845e08dc4ceda08f2e17207c267ade97dc5458b445405736',\n  blockNumber: 74665,\n  contractAddress: null,\n  cumulativeGasUsed: 108549,\n  from: 'atp1jtfqqqr6436ppj6ccnrh8xjg7qals3ctnnmurp',\n  gasUsed: 108549,\n  logsBloom:\n   '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',\n  status: true,\n  to: 'atp12ts3s0zd7s8hm2vwv8wxe3rpvrwpv6tpsx8shx',\n  transactionHash:\n   '0x2b5e590df7e70ad428b1ccb06bda5dcce47f84c4d981c2fb475aca9ec9d0000a',\n  transactionIndex: 0,\n  events: {} }\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step4.")," Query contract"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"helloworld.methods.get_message_body(0).call()\n")),(0,r.kt)("p",null,"Description\uff1a"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"helloWorld")," the contract object created"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"methods")," specify the call method"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"get_message_body")," method in the HelloWorld contract, which has an input parameter of type int"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"call")," specify the query method")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"development-costs"},"Development Costs"),(0,r.kt)("h3",{id:"summary"},"Summary"),(0,r.kt)("p",null,"In a blockchain system, developing smart contracts based on any public chain system involves the development cost of resource expenditure. For example, deploying/calling smart contracts on the network, energy transfer, pledge/delegation and other operations all require a certain cost. Different blockchain network development costs are different. There are two types of virtual machines running in the Alaya network. ",(0,r.kt)("inlineCode",{parentName:"p"},"EVM")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"WASM"),", the cost of developing smart contracts on different virtual machines is also different. This article will compare the different development costs of small contracts, medium contracts and large contracts in the form of a table. At the same time, we will compare the ",(0,r.kt)("inlineCode",{parentName:"p"},"EVM"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"WASM")," virtual machine of ",(0,r.kt)("inlineCode",{parentName:"p"},"Alaya")," with the Ethereum virtual machine. In terms of contracts, a simple ",(0,r.kt)("inlineCode",{parentName:"p"},"SET/GET")," function contract is used as a small test contract. The medium-sized contract example will use an open source ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/yep/eth-tweet"},"Tweet")," contract The large contract is a smart contract that implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"ERC20")," standard."),(0,r.kt)("h4",{id:"data-overview"},"Data Overview"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Simple Storage Contract")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Platform"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Contract Level"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Size"),(0,r.kt)("th",{parentName:"tr",align:"left"},"GasUsed"),(0,r.kt)("th",{parentName:"tr",align:"left"},"GasPrice"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Amount"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Remark"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Alaya-EVM"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Small-sized"),(0,r.kt)("td",{parentName:"tr",align:"left"},"0.3 kb"),(0,r.kt)("td",{parentName:"tr",align:"left"},"76953"),(0,r.kt)("td",{parentName:"tr",align:"left"},"5,000,000,000 ",(0,r.kt)("inlineCode",{parentName:"td"},"VON")),(0,r.kt)("td",{parentName:"tr",align:"left"},"384765 ",(0,r.kt)("inlineCode",{parentName:"td"},"gVON")),(0,r.kt)("td",{parentName:"tr",align:"left"},"0.000384765 ",(0,r.kt)("inlineCode",{parentName:"td"},"ATP"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Ethereum"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Small-sized"),(0,r.kt)("td",{parentName:"tr",align:"left"},"0.3 kb"),(0,r.kt)("td",{parentName:"tr",align:"left"},"127173"),(0,r.kt)("td",{parentName:"tr",align:"left"},"5,000,000,000 ",(0,r.kt)("inlineCode",{parentName:"td"},"wei")),(0,r.kt)("td",{parentName:"tr",align:"left"},"635865 ",(0,r.kt)("inlineCode",{parentName:"td"},"Gwei")),(0,r.kt)("td",{parentName:"tr",align:"left"},"0.000635865 ",(0,r.kt)("inlineCode",{parentName:"td"},"ETH"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Alaya-WASM"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Small-sized"),(0,r.kt)("td",{parentName:"tr",align:"left"},"13.55 kb"),(0,r.kt)("td",{parentName:"tr",align:"left"},"184043"),(0,r.kt)("td",{parentName:"tr",align:"left"},"5,000,000,000 ",(0,r.kt)("inlineCode",{parentName:"td"},"VON")),(0,r.kt)("td",{parentName:"tr",align:"left"},"920215 ",(0,r.kt)("inlineCode",{parentName:"td"},"gVON")),(0,r.kt)("td",{parentName:"tr",align:"left"},"0.000920215 ",(0,r.kt)("inlineCode",{parentName:"td"},"ATP"))))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"eth-tweet Contract")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Platform"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Contract Level"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Size"),(0,r.kt)("th",{parentName:"tr",align:"left"},"GasUsed"),(0,r.kt)("th",{parentName:"tr",align:"left"},"GasPrice"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Amount"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Remark"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Alaya-EVM"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Medium-sized"),(0,r.kt)("td",{parentName:"tr",align:"left"},"2.08 kb"),(0,r.kt)("td",{parentName:"tr",align:"left"},"257065"),(0,r.kt)("td",{parentName:"tr",align:"left"},"5,000,000,000 ",(0,r.kt)("inlineCode",{parentName:"td"},"VON")),(0,r.kt)("td",{parentName:"tr",align:"left"},"1285325 ",(0,r.kt)("inlineCode",{parentName:"td"},"gVON")),(0,r.kt)("td",{parentName:"tr",align:"left"},"0.001285325 ",(0,r.kt)("inlineCode",{parentName:"td"},"ATP"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Ethereum"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Medium-sized"),(0,r.kt)("td",{parentName:"tr",align:"left"},"2.08 kb"),(0,r.kt)("td",{parentName:"tr",align:"left"},"621385"),(0,r.kt)("td",{parentName:"tr",align:"left"},"5,000,000,000 ",(0,r.kt)("inlineCode",{parentName:"td"},"wei")),(0,r.kt)("td",{parentName:"tr",align:"left"},"3106925 ",(0,r.kt)("inlineCode",{parentName:"td"},"Gwei")),(0,r.kt)("td",{parentName:"tr",align:"left"},"0.003106925 ",(0,r.kt)("inlineCode",{parentName:"td"},"ETH"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Alaya-WASM"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Medium-sized"),(0,r.kt)("td",{parentName:"tr",align:"left"},"30.07 kb"),(0,r.kt)("td",{parentName:"tr",align:"left"},"349713"),(0,r.kt)("td",{parentName:"tr",align:"left"},"5,000,000,000 ",(0,r.kt)("inlineCode",{parentName:"td"},"VON")),(0,r.kt)("td",{parentName:"tr",align:"left"},"1748565 ",(0,r.kt)("inlineCode",{parentName:"td"},"gVON")),(0,r.kt)("td",{parentName:"tr",align:"left"},"0.001748565 ",(0,r.kt)("inlineCode",{parentName:"td"},"ATP"))))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"ERC20 Token Contract")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Platform"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Contract Level"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Size"),(0,r.kt)("th",{parentName:"tr",align:"left"},"GasUsed"),(0,r.kt)("th",{parentName:"tr",align:"left"},"GasPrice"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Amount"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Remark"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Alaya-EVM"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Large-sized"),(0,r.kt)("td",{parentName:"tr",align:"left"},"4.45 kb"),(0,r.kt)("td",{parentName:"tr",align:"left"},"552823"),(0,r.kt)("td",{parentName:"tr",align:"left"},"5,000,000,000 ",(0,r.kt)("inlineCode",{parentName:"td"},"VON")),(0,r.kt)("td",{parentName:"tr",align:"left"},"2764115 ",(0,r.kt)("inlineCode",{parentName:"td"},"gVON")),(0,r.kt)("td",{parentName:"tr",align:"left"},"0.002764115 ",(0,r.kt)("inlineCode",{parentName:"td"},"ATP"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Ethereum"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Large-sized"),(0,r.kt)("td",{parentName:"tr",align:"left"},"4.45 kb"),(0,r.kt)("td",{parentName:"tr",align:"left"},"1282171"),(0,r.kt)("td",{parentName:"tr",align:"left"},"5,000,000,000 ",(0,r.kt)("inlineCode",{parentName:"td"},"wei")),(0,r.kt)("td",{parentName:"tr",align:"left"},"6410855 ",(0,r.kt)("inlineCode",{parentName:"td"},"Gwei")),(0,r.kt)("td",{parentName:"tr",align:"left"},"0.006410855 ",(0,r.kt)("inlineCode",{parentName:"td"},"ETH"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Alaya-WASM"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Large-sized"),(0,r.kt)("td",{parentName:"tr",align:"left"},"35.9 kb"),(0,r.kt)("td",{parentName:"tr",align:"left"},"486274"),(0,r.kt)("td",{parentName:"tr",align:"left"},"5,000,000,000 ",(0,r.kt)("inlineCode",{parentName:"td"},"VON")),(0,r.kt)("td",{parentName:"tr",align:"left"},"2431370 ",(0,r.kt)("inlineCode",{parentName:"td"},"gVON")),(0,r.kt)("td",{parentName:"tr",align:"left"},"0.00243137 ",(0,r.kt)("inlineCode",{parentName:"td"},"ATP"))))),(0,r.kt)("h3",{id:"small-sized-contract"},"Small-sized Contract"),(0,r.kt)("h4",{id:"simple-storage-contract"},"Simple Storage Contract"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"EVM Sample Code")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"pragma solidity ^0.4.12;\n\ncontract SimpleTest {\n\n    uint public age;\n\n    function setAge(uint _input) public {\n        age = _input;\n    }\n\n    function getAge() public constant returns (uint) {\n        return age;\n    }\n}\n")),(0,r.kt)("p",null,"ByteCode"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"608060405234801561001057600080fd5b50610117806100206000396000f3006080604052600436106053576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063262a9dff146058578063967e6e65146080578063d5dcf1271460a8575b600080fd5b348015606357600080fd5b50606a60d2565b6040518082815260200191505060405180910390f35b348015608b57600080fd5b50609260d8565b6040518082815260200191505060405180910390f35b34801560b357600080fd5b5060d06004803603810190808035906020019092919050505060e1565b005b60005481565b60008054905090565b80600081905550505600a165627a7a7230582079e51340567895e1097e1c9115e778c3d982b8e71b6997c57f1ba497c56c8b3b0029\n")),(0,r.kt)("p",null,"ByteSize\uff1a",(0,r.kt)("inlineCode",{parentName:"p"},"311 byte => 0.3 kb")),(0,r.kt)("hr",null),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"WASM Sample Code")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'#include <platon/platon.hpp>\n#include <string>\nusing namespace platon;\n\nCONTRACT SimpleStorage: public platon::Contract\n{\n    public:\n        ACTION void init(){}\n\n        ACTION void set(uint64_t input)\n        {\n            storedData.self() = input;\n        }\n\n        CONST uint64_t get()\n        {\n            return storedData.self();\n        }\n\n    private:\n        platon::StorageType<"sstored"_n, uint64_t> storedData;\n};\n\nPLATON_DISPATCH(SimpleStorage,(init)(set)(get))\n')),(0,r.kt)("p",null,"ByteCode"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/PlatONnetwork/alaya-devdocs/blob/master/zh-cn/Development/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91.assets/SimpleStorage_wasm.bin"},"Click to view bincode")),(0,r.kt)("p",null,"ByteSize: ",(0,r.kt)("inlineCode",{parentName:"p"},"13882 byte => 13.55 kb")),(0,r.kt)("hr",null),(0,r.kt)("h6",{id:"cost"},"Cost"),(0,r.kt)("p",null,"Alaya-EVM"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"GasUsed: 76953"),(0,r.kt)("li",{parentName:"ul"},"GasPrice: 5,000,000,000 (5 ",(0,r.kt)("inlineCode",{parentName:"li"},"gVON"),")"),(0,r.kt)("li",{parentName:"ul"},"Costs: 384765 ",(0,r.kt)("inlineCode",{parentName:"li"},"gVON"),"\uff080.000384765 ",(0,r.kt)("inlineCode",{parentName:"li"},"ATP"),"\uff09")),(0,r.kt)("p",null,"Ethereum"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"GasUsed: 127173"),(0,r.kt)("li",{parentName:"ul"},"GasPrice: 5,000,000,000 (5 ",(0,r.kt)("inlineCode",{parentName:"li"},"Gwei"),")"),(0,r.kt)("li",{parentName:"ul"},"Costs: 635865 ",(0,r.kt)("inlineCode",{parentName:"li"},"Gwei"),"\uff080.000635865 ",(0,r.kt)("inlineCode",{parentName:"li"},"ETH"),"\uff09")),(0,r.kt)("p",null,"Alaya-WASM"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"GasUsed: 184043"),(0,r.kt)("li",{parentName:"ul"},"GasPrice: 5,000,000,000 (5 ",(0,r.kt)("inlineCode",{parentName:"li"},"gVON"),")"),(0,r.kt)("li",{parentName:"ul"},"Costs: 920215 ",(0,r.kt)("inlineCode",{parentName:"li"},"gVON"),"\uff080.000920215 ",(0,r.kt)("inlineCode",{parentName:"li"},"ATP"),"\uff09")),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"medium-sized-contract"},"Medium-sized Contract"),(0,r.kt)("h4",{id:"eth-tweet"},"Eth-Tweet"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"EVM Sample Code")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/PlatONnetwork/alaya-devdocs/blob/master/zh-cn/Development/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91.assets/account.sol"},"Click to view code")),(0,r.kt)("p",null,"ByteCode"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/PlatONnetwork/alaya-devdocs/blob/master/zh-cn/Development/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91.assets/Tweet_evm.bin"},"Click to view bincode")),(0,r.kt)("p",null,"ByteSize: ",(0,r.kt)("inlineCode",{parentName:"p"},"2130.5 byte => 2.08 kb")),(0,r.kt)("hr",null),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"WASM Sample Code")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'#include <platon/platon.hpp>\n#include <string>\nusing namespace platon;\n\n// data structure of a single tweet.\nstruct Tweet{\n\n    public:\n        uint64_t timestamp;\n        std::string tweetString;\n\n    public:\n        Tweet(){}\n        Tweet(uint64_t &timestamp, const std::string &tweet):timestamp(timestamp), tweetString(tweet) {\n        }\n\n    public:\n        PLATON_SERIALIZE(Tweet, (timestamp)(tweetString))\n};\n\nCONTRACT TweetAccount: public platon::Contract\n{\n    private:\n        // "array" of all tweets of this account: maps the tweet id to the actual tweet.\n        platon::StorageType<"smapping"_n, std::map<std::uint64_t, Tweet>> _tweets;\n        // total number of tweets in the above _tweets mapping.\n        platon::StorageType<"suint"_n, uint64_t> _numberOfTweets;\n        // "owner" of this account: only admin is allowed to tweet.\n        platon::StorageType<"saddress"_n, Address> _adminAddress;\n\n    public:\n        ACTION void init()\n        {\n            _numberOfTweets.self() = 0;\n            _adminAddress.self() = platon::platon_caller();\n        }\n\n        // returns true if caller of function("sender") is admin.\n        CONST bool isAdmin(){\n            return platon::platon_caller() == _adminAddress.self();\n        }\n\n        // create new tweet\n        ACTION int64_t tweet(const std::string& tweetString) {\n            int64_t result = 0;\n            if(!isAdmin()){\n                // only owner is allowed to create tweets for this account.\n                result = -1;\n            } else if (tweetString.length() > 160) {\n                // tweet contains more than 160 bytes.\n                result = -2;\n            } else {\n                _tweets.self()[_numberOfTweets].timestamp = platon_timestamp();\n                _tweets.self()[_numberOfTweets].tweetString = tweetString;\n                _numberOfTweets.self() = _numberOfTweets.self() + 1;\n                result = 0; // success.\n            }\n            return result;\n        }\n\n        CONST std::string getTweet(uint64_t tweetId){\n            // returns two values\n            std::string tweetString = _tweets.self()[tweetId].tweetString;\n            uint64_t timestamp = _tweets.self()[tweetId].timestamp;\n            return tweetString;\n        }\n\n        CONST std::string getLatestTweet() {\n            // returns three values.\n            std::string tweetString = _tweets.self()[_numberOfTweets.self() - 1].tweetString;\n            uint64_t timestamp = _tweets.self()[_numberOfTweets.self() - 1].timestamp;\n            uint64_t numberOfTweets = _numberOfTweets.self();\n            return tweetString;\n        }\n\n        CONST Address getOwnerAddress() {\n            return _adminAddress.self();\n        }\n\n        CONST uint64_t getNumberOfTweets() {\n            return _numberOfTweets.self();\n        }\n\n        ACTION void adminRetrieveDonations(const Address& receiver) {\n            if(isAdmin()){\n                Address caddr = platon_address();\n                Energon e = platon_balance(caddr);\n                platon_transfer(receiver, e);\n            }\n        }\n\n        CONST Address caddr(){\n            return platon_address();\n        }\n\n        CONST std::string caddrBalance(Address receiver){\n            //Address caddr = platon_address();\n            Energon e = platon_balance(receiver);\n            return std::to_string(e.Get());\n        }\n\n        ACTION void adminDeleteAccount(){\n            if(isAdmin()){\n                // this is a predefined function, it deletes theh contract and returns all funds to the owner.\n                platon_destroy(_adminAddress.self());\n            }\n        }\n};\n\nPLATON_DISPATCH(TweetAccount,(init)(isAdmin)(tweet)(getTweet)(getLatestTweet)\n(getOwnerAddress)(getNumberOfTweets)(adminRetrieveDonations)(adminDeleteAccount)\n(caddr)(caddrBalance))\n')),(0,r.kt)("p",null,"ByteCode"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/PlatONnetwork/alaya-devdocs/blob/master/zh-cn/Development/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91.assets/Tweet_wasm.bin"},"Click to view bincode")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"")),(0,r.kt)("p",null,"ByteSize: ",(0,r.kt)("inlineCode",{parentName:"p"},"30788")," byte => 30.07 kb`"),(0,r.kt)("hr",null),(0,r.kt)("h6",{id:"costs"},"Costs"),(0,r.kt)("p",null,"Alaya-EVM"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"GasUsed: 257065"),(0,r.kt)("li",{parentName:"ul"},"GasPrice: 5,000,000,000 (5 ",(0,r.kt)("inlineCode",{parentName:"li"},"gVON"),")"),(0,r.kt)("li",{parentName:"ul"},"Costs: 1285325 ",(0,r.kt)("inlineCode",{parentName:"li"},"gVON"),"\uff080.001285325 ",(0,r.kt)("inlineCode",{parentName:"li"},"ATP"),"\uff09")),(0,r.kt)("p",null,"Ethereum"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"GasUsed: 621385"),(0,r.kt)("li",{parentName:"ul"},"GasPrice: 5,000,000,000 (5 ",(0,r.kt)("inlineCode",{parentName:"li"},"Gwei"),")"),(0,r.kt)("li",{parentName:"ul"},"Costs: 3106925 ",(0,r.kt)("inlineCode",{parentName:"li"},"Gwei"),"\uff080.003106925 ",(0,r.kt)("inlineCode",{parentName:"li"},"ETH"),"\uff09")),(0,r.kt)("p",null,"Alaya-WASM"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"GasUsed: 349713"),(0,r.kt)("li",{parentName:"ul"},"GasPrice: 5,000,000,000 (5 ",(0,r.kt)("inlineCode",{parentName:"li"},"gVON"),")"),(0,r.kt)("li",{parentName:"ul"},"Costs: 1748565 ",(0,r.kt)("inlineCode",{parentName:"li"},"gVON"),"\uff080.001748565 ",(0,r.kt)("inlineCode",{parentName:"li"},"ATP"),"\uff09")),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"large-sized-contract"},"Large-sized Contract"),(0,r.kt)("h4",{id:"erc20-token-contract"},"ERC20 Token Contract"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"EVM Sample Code")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/PlatONnetwork/alaya-devdocs/blob/master/zh-cn/Development/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91.assets/token.sol"},"Click to view code")),(0,r.kt)("p",null,"ByteCode"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/PlatONnetwork/alaya-devdocs/blob/master/zh-cn/Development/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91.assets/Token_evm.bin"},"Click to view bincode")),(0,r.kt)("p",null,"ByteSize: ",(0,r.kt)("inlineCode",{parentName:"p"},"4557.5 byte => 4.45 kb")),(0,r.kt)("hr",null),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"WASM Sample Code")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'#include <platon/platon.hpp>\n#include <string>\nusing namespace platon;\n\nclass Token {\n    public:\n        // total amount of tokens\n        platon::StorageType<"totalsupply"_n, uint64_t> totalSupply;\n\n    public: // event\n        // define: _from, _to, _value\n        PLATON_EVENT2(Transfer, Address, Address, uint64_t);\n        // define: _owner, _spender, _value\n        PLATON_EVENT2(Approval, Address, Address, uint64_t);\n\n    public:\n        // @param _owner The address from which the balance will be retrieved\n        // @return The balance.\n        virtual uint64_t balanceOf(Address _owner) = 0;\n\n        // @notice send \'_value\' token to `_to` from `msg.sender`\n        // @param _to THe address of the recipient.\n        // @param _value The amount of token to be transferred.\n        // @return Whether the transfer was successful or not.\n        virtual bool transfer(Address _to, uint64_t _value) = 0;\n\n        // @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n        // @param _from The address of the sender.\n        // @param _to The address of the recepient.\n        // @param _value The amount of token to be transferred.\n        // @return Whether the transfer was successful or not.\n        virtual bool transferFrom(Address _from, Address _to, uint64_t _value) = 0;\n\n        // @notice `msg.sender` approves `_spender` to spend `_value` tokens\n        // @param _spender The address of the account able to transfer the tokens\n        // @param _value The amount of tokens to be approved for transfer\n        // @return Whether thee approval was successful or not.\n        virtual bool approve(Address _spender, uint64_t _value) = 0;\n\n        // @param _owner The address of the account owning tokens\n        // @param _spender The address of the account able to transfer the tokens\n        // @return Amount of remaining tokens allowed to spent.\n        virtual uint64_t allowance(Address _owner, Address _spender) = 0;\n};\n\n// You should inherit from StandardTOken or, for a token like you would want\n// to deploy in something like MIst, see HumanStandardToken.cpp.\n// (This implements ONLY the standard functions and NOTHING else.\n// If you deploy this, you won\'t have anthing useful.)\nclass StandardToken: public Token\n{\n    protected:\n        platon::StorageType<"balances"_n, std::map<Address, uint64_t>> balances;\n        platon::StorageType<"allowed"_n, std::map<Address, std::map<Address, uint64_t>>> allowed;\n\n    public:\n        CONST uint64_t balanceOf(Address _owner) {\n            return balances.self()[_owner];\n        }\n\n        ACTION bool transfer(Address _to, uint64_t _value){\n            // Default assumes totalSupply can\'t be over max(2^64 - 1)\n            // If your token leaves out totalSupply and can issue more tokens as time goes on,\n            // you need to check if it doesn\'t wrap.\n            // Replace the if with this on instead.\n            Address sender = platon_caller();\n            if (balances.self()[sender] >= _value && _value > 0) {\n                balances.self()[sender] -= _value;\n                balances.self()[_to] += _value;\n                PLATON_EMIT_EVENT2(Transfer, sender, _to, _value);\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        ACTION bool transferFrom(Address _from, Address _to, uint64_t _value) {\n            // same as above. Replace this line with the following if you want to protect against\n            // wrapping uints.\n            Address sender = platon_caller();\n            if(balances.self()[_from] >= _value\n                && allowed.self()[_from][sender] >= _value && _value > 0){\n                balances.self()[_to] += _value;\n                balances.self()[_from] -= _value;\n                PLATON_EMIT_EVENT2(Transfer, _from, _to, _value);\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        ACTION bool approve(Address _spender, uint64_t _value){\n            Address sender = platon_caller();\n            allowed.self()[sender][_spender] = _value;\n            PLATON_EMIT_EVENT2(Approval, sender, _spender, _value);\n            return true;\n        }\n\n        CONST uint64_t allowance(Address _owner, Address _spender){\n            return allowed.self()[_owner][_spender];\n        }\n};\n\n\nCONTRACT LATToken: public platon::Contract, public StandardToken\n{\n\n    public:\n        platon::StorageType<"name"_n, std::string> name;        // fancy name: eg Alaya Token\n        platon::StorageType<"decimals"_n, uint8_t> decimals;    // HOw many decimals to show.\n        platon::StorageType<"symbol"_n, std::string> symbol;    // An identifier: eg LTT\n        platon::StorageType<"version"_n, std::string> version;  // 0.1 standard. Just an arbitrary versioning scheme.\n\n    public:\n        ACTION void init(uint64_t _initialAmount, const std::string& _tokenName,\n            uint8_t _decimalUnits, const std::string& _tokenSymbol)\n        {\n            Address sender = platon_caller();\n            balances.self()[sender] = _initialAmount;       // Give the creator all initial tokens.\n            totalSupply.self() = _initialAmount;            // Update total supply.\n            name.self() = _tokenName;                       // Set the name for display purposes\n            decimals.self() = _decimalUnits;                // Amount of decimals for display purposes\n            symbol.self() = _tokenSymbol;                   // Set the symbol for display purposes.\n        }\n\n        CONST std::string getName(){\n            return name.self();\n        }\n\n        CONST uint8_t getDecimals(){\n            return decimals.self();\n        }\n\n        CONST std::string getSymbol(){\n            return symbol.self();\n        }\n\n        CONST uint64_t getTotalSupply(){\n            return totalSupply.self();\n        }\n\n        // Approves and then calls the receiving contract.\n        ACTION bool approveAndCall(Address _spender, uint64_t _value, const bytes& _extraData) {\n            Address sender = platon_caller();\n            allowed.self()[sender][_spender] = _value;\n            PLATON_EMIT_EVENT2(Approval, sender, _spender, _value);\n            // call the receiveApproval function on the contract you want to be notified. This\n            // crafts the function signature manually so one doesn\'t have to include a contract\n            // in here just for this.\n            // define: receiveApproval(Address _from, uint64_t _value, Address _tokenContract, bytes& _extraDaa)\n            // it is assumed that when does this that the call should succeed.\n            return true;\n        }\n};\n\nPLATON_DISPATCH(LATToken,(init)(balanceOf)(transfer)(transferFrom)(approve)(allowance)\n(getName)(getDecimals)(getSymbol)(getTotalSupply)(approveAndCall))\n')),(0,r.kt)("p",null,"ByteCode"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/PlatONnetwork/alaya-devdocs/blob/master/zh-cn/Development/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91.assets/Token_wasm.bin"},"Click to view bincode")),(0,r.kt)("p",null,"ByteSize: ",(0,r.kt)("inlineCode",{parentName:"p"},"36764 byte => 35.9 kb")),(0,r.kt)("hr",null),(0,r.kt)("h6",{id:"costs-1"},"Costs"),(0,r.kt)("p",null,"Alaya-EVM"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"GasUsed: 552823"),(0,r.kt)("li",{parentName:"ul"},"GasPrice: 5,000,000,000 (5 ",(0,r.kt)("inlineCode",{parentName:"li"},"gVON"),")"),(0,r.kt)("li",{parentName:"ul"},"Costs: 2764115 ",(0,r.kt)("inlineCode",{parentName:"li"},"gVON"),"\uff080.002764115 ",(0,r.kt)("inlineCode",{parentName:"li"},"ATP"),"\uff09")),(0,r.kt)("p",null,"Ethereum"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"GasUsed: 1282171"),(0,r.kt)("li",{parentName:"ul"},"GasPrice: 5,000,000,000 (5 ",(0,r.kt)("inlineCode",{parentName:"li"},"Gwei"),")"),(0,r.kt)("li",{parentName:"ul"},"Costs: 6410855 ",(0,r.kt)("inlineCode",{parentName:"li"},"Gwei"),"\uff080.006410855 ",(0,r.kt)("inlineCode",{parentName:"li"},"ETH"),"\uff09")),(0,r.kt)("p",null,"Alaya-WASM"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"GasUsed: 486274"),(0,r.kt)("li",{parentName:"ul"},"GasPrice: 5,000,000,000 (5 ",(0,r.kt)("inlineCode",{parentName:"li"},"gVON"),")"),(0,r.kt)("li",{parentName:"ul"},"Costs: 2431370 ",(0,r.kt)("inlineCode",{parentName:"li"},"gVON"),"\uff080.00243137 ",(0,r.kt)("inlineCode",{parentName:"li"},"ATP"),"\uff09")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"best-practice"},"Best Practice"),(0,r.kt)("h3",{id:"introduction-1"},"Introduction"),(0,r.kt)("p",null,"This guide introduces users to some key points that need to be paid attention to\nin the development of smart contracts, mainly in the practice of actual\ndevelopment. Users can use this guide to quickly understand how to set a\nreasonable fee for a transaction, how to avoid losing the fee due to transaction\nfailure, and how to encode a more standardized smart contract."),(0,r.kt)("h3",{id:"reasonable-cost-setting"},"Reasonable Cost Setting"),(0,r.kt)("p",null,"When you need to deploy a contract on the main network of Alaya, you need to set a reasonable fee limit. The fee limit refers to the upper limit of the energy consumption cost of smart contract deployment/execution in Alaya. This restriction is mainly accomplished through Gas. Gas is the fuel value of the Alaya network world, which determines the normal operation of the Alaya network ecosystem. Gas is usually used to measure how much \u201cwork\u201d is required to perform certain actions, and these workloads are the amount of fees that need to be paid to the Alaya network in order to perform the action. In a simple understanding, Gas is the commission for network miners, and is paid by ATP. Any transaction, contract execution, and data storage on the network need to use Gas."),(0,r.kt)("p",null,"Alaya is similar to Ethereum\u2019s blockchain system. It uses ",(0,r.kt)("inlineCode",{parentName:"p"},"ATP")," for payment and\nmaintenance networks. One ",(0,r.kt)("inlineCode",{parentName:"p"},"ATP")," is divided into: ",(0,r.kt)("inlineCode",{parentName:"p"},"mATP/uATP/gVON/mVON/kVON/VON"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"VON")," is the smallest unit."),(0,r.kt)("p",null,"Gas consists of two parts: GasLimit and GasPrice. GasLimit is the maximum Gas consumption (minimum 21,000) that a user is willing to pay to perform an operation or confirm a transaction. GasPrice is the unit price of each Gas."),(0,r.kt)("p",null,"When a user sends a transaction, GasLimit and GasPrice are set. GasLimit ","*"," GasPrice is the user\u2019s transaction cost, and the cost is rewarded to the miner as a commission."),(0,r.kt)("p",null,"The higher the GasPrice of the transaction, the higher the execution priority of the transaction and the greater the transaction cost. After each transaction is completed, the remaining unused Gas will be returned to the sender\u2019s address account. It is important to note that if the execution of the transaction fails because the GasLimit is set too low, the Gas will not be returned to the user\u2019s address at this time, and the user still needs to pay the energy cost for the failed transaction. Therefore, regardless of whether the transaction is executed successfully, the transaction sender needs to pay a certain calculation fee to the miner."),(0,r.kt)("p",null,"In the Alaya network, the maximum gas limit is ",(0,r.kt)("inlineCode",{parentName:"p"},"100,800,000")," and the minimum is 22,000. Too low or too high will cause transaction failure. When deploying large contracts or calling complex functions in contracts, you can increase the gas limit, for example: 1,000,000. If it is a normal transfer, set it to the lowest value. The specific value needs to be estimated according to the size and complexity of the contract. Before the contract is released, the interface platon_estimateGas can be called for approximate estimation to avoid failure due to insufficient Gas."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"ATP Unit Conversion")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Unit"),(0,r.kt)("th",{parentName:"tr",align:null},"VON Value"),(0,r.kt)("th",{parentName:"tr",align:null},"VON"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"VON"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"kVON"),(0,r.kt)("td",{parentName:"tr",align:null},"1e3 VON"),(0,r.kt)("td",{parentName:"tr",align:null},"1,000")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mVON"),(0,r.kt)("td",{parentName:"tr",align:null},"1e6 VON"),(0,r.kt)("td",{parentName:"tr",align:null},"1,000,000")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"gVON"),(0,r.kt)("td",{parentName:"tr",align:null},"1e9 VON"),(0,r.kt)("td",{parentName:"tr",align:null},"1,000,000,000")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"microATP"),(0,r.kt)("td",{parentName:"tr",align:null},"1e12 VON"),(0,r.kt)("td",{parentName:"tr",align:null},"1,000,000,000,000")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"milliATP"),(0,r.kt)("td",{parentName:"tr",align:null},"1e15 VON"),(0,r.kt)("td",{parentName:"tr",align:null},"1,000,000,000,000,000")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ATP"),(0,r.kt)("td",{parentName:"tr",align:null},"1e18 VON"),(0,r.kt)("td",{parentName:"tr",align:null},"1,000,000,000,000,000,000")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"kATP"),(0,r.kt)("td",{parentName:"tr",align:null},"1e21 VON"),(0,r.kt)("td",{parentName:"tr",align:null},"1,000,000,000,000,000,000,000")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mATP"),(0,r.kt)("td",{parentName:"tr",align:null},"1e24 VON"),(0,r.kt)("td",{parentName:"tr",align:null},"1,000,000,000,000,000,000,000,000")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"gATP"),(0,r.kt)("td",{parentName:"tr",align:null},"1e27 VON"),(0,r.kt)("td",{parentName:"tr",align:null},"1,000,000,000,000,000,000,000,000,000")))),(0,r.kt)("h3",{id:"avoid-timeouts"},"Avoid Timeouts"),(0,r.kt)("p",null,"Sending transactions on the Alaya network does not have the concept of timeout, but it will eventually stop according to the set gas limit value. If the limit value is lower than the consumption required for contract deployment, the transaction execution fails and the corresponding processing fee will be deducted. The fee setting cannot be infinite, because in the network, the block itself has a maximum GasLimit value. When the GasLimit of the transaction exceeds this value, the transaction will not be accepted."),(0,r.kt)("p",null,"If the call function of a published contract is called (a call is a stateless operation in the contract logic), there is a 5s timeout limit. If the contract logic is not executed within 5s, a timeout will occur and the virtual machine will forcely exit , causing the query to fail."),(0,r.kt)("p",null,"To avoid contract-related transaction failures, try breaking large contracts into smaller pieces and referencing each other as needed. To avoid infinite loops, be aware of common pitfalls and recursive calls."),(0,r.kt)("h3",{id:"punishment-for-illegal-operations"},"Punishment For Illegal Operations"),(0,r.kt)("p",null,"If the smart contract is not compiled by a standard valid compiler, or the instruction code is changed at will, the opcode will be invalid. This type of contract not only fails to be deployed and executed successfully, but also generates a full amount (GasLimit ","*"," GasPrice) penalty. The transaction fee for the current transaction will be deducted. This is a very strong penalty. If the operator does not pay attention to this point and keep retrying, then the cost will be higher and the cost will be heavier."),(0,r.kt)("p",null,"In general, invalid opcodes have the following conditions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Manually changed the instruction code for the normally compiled contract"),(0,r.kt)("li",{parentName:"ul"},"The contract compiler version is not consistent with the contract version\nsupported by the network lock"),(0,r.kt)("li",{parentName:"ul"},"Use float type to do operation")),(0,r.kt)("p",null,"When operating a contract in the Alaya network. First, you must confirm the smart contract version supported by the current network, and then select the compiler of the corresponding version pair."),(0,r.kt)("p",null,"The normal operation is to use the latest Truffle/PlatON-CDT officially provided by Alaya to compile/deploy/execute the contract. At the same time, before switching to the main network, it must be validated on the test network."),(0,r.kt)("h3",{id:"cc-language-limit"},"C/C++ Language Limit"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"C/C++ features not supported")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"float type(float/double)"),(0,r.kt)("li",{parentName:"ul"},"typeid/dynamic_cast(-fno-rtti)"),(0,r.kt)("li",{parentName:"ul"},"try-catch(-fno-exception)"),(0,r.kt)("li",{parentName:"ul"},"features after C++17")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"libc not supported header files")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"signal.h"),(0,r.kt)("li",{parentName:"ul"},"math.h"),(0,r.kt)("li",{parentName:"ul"},"locale.h"),(0,r.kt)("li",{parentName:"ul"},"errno.h"),(0,r.kt)("li",{parentName:"ul"},"uchar.h"),(0,r.kt)("li",{parentName:"ul"},"time.h")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"libc++ not suppported header files")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"rand"),(0,r.kt)("li",{parentName:"ul"},"atomics"),(0,r.kt)("li",{parentName:"ul"},"thread"),(0,r.kt)("li",{parentName:"ul"},"random")),(0,r.kt)("h3",{id:"coding-standards"},"Coding Standards"),(0,r.kt)("h4",{id:"naming-rules"},"Naming rules"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The style of a name immediately informs us what sort of thing the named entity\nis: a type, a variable, a function, a constant, a macro, etc.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Use terminology within the blockchain industry.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Use as few abbreviations as possible. If you must use them, it is recommended\nto use public abbreviations and custom abbreviations.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Filenames should be all lowercase and can include underscores (","_",") or dashes\n(-).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For smart contracts, the file name is consistent with the contract name.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Type names start with a capital letter and have a capital letter for each new\nword, with no underscores: ",(0,r.kt)("inlineCode",{parentName:"p"},"MyExcitingClass"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"MyExcitingEnum"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The names of variables (including function parameters) and data members are\nall lowercase, with underscores between words. Data members of classes (but\nnot structs) additionally have trailing underscores. For instance:\n",(0,r.kt)("inlineCode",{parentName:"p"},"a_local_variable"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"a_struct_data_member"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"a_class_data_member_"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'Variables declared constexpr or const, and whose value is fixed for the\nduration of the program, are named with a leading "k" followed by mixed case.\nUnderscores can be used as separators in the rare cases where capitalization\ncannot be used for separation. For example:'),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"const int kDaysInAWeek = 7;\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Regular functions have mixed case; accessors and mutators may be named like\nvariables: ",(0,r.kt)("inlineCode",{parentName:"p"},"MyExcitingFunction()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"MyExcitingMethod()"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"my_exciting_member_variable()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"set_my_exciting_member_variable()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Enumerators (for both scoped and unscoped enums) should be named either like\nconstants or like macros: either ",(0,r.kt)("inlineCode",{parentName:"p"},"kEnumName")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"ENUM_NAME"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If you are naming something that is analogous to an existing C or C++ entity\nthen you can follow the existing naming convention scheme."))),(0,r.kt)("h4",{id:"document-format-for-smart-contracts"},"Document Format For Smart Contracts"),(0,r.kt)("p",null,"File Layout Rules:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Generally more than 1000 lines of program code is difficult to read, try to\navoid the situation that the number of lines of code in a file is too long.\nEach contract document should contain only a single contract class or contract\ninterface.")),(0,r.kt)("p",null,"Order Of Files:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Notes on files: All contract source files have a note at the beginning, which\nlists the copyright statement, file name, function description, and creation\nand modification records of the file."),(0,r.kt)("li",{parentName:"ul"},"Remarks for class or interface: Comments should be made before class and\ninterface definitions, including descriptions of classes and interfaces,\nlatest modifiers, version numbers, reference links, etc."),(0,r.kt)("li",{parentName:"ul"},"The order of class member: first the public level, then the protection\nlevel, and finally the private level."),(0,r.kt)("li",{parentName:"ul"},"Member functions: Functions within a contract should be grouped by module, not by\nscope or access permissions.")),(0,r.kt)("h4",{id:"feature-uses-advice"},"Feature Uses Advice"),(0,r.kt)("h5",{id:"structs-vs-classes"},"Structs vs Classes"),(0,r.kt)("p",null,"Use a struct only for passive objects that carry data; everything else is a\nclass."),(0,r.kt)("p",null,"The struct and class keywords behave almost identically in C++. We add our own\nsemantic meanings to each keyword, so you should use the appropriate keyword for\nthe data-type you're defining."),(0,r.kt)("p",null,"Structs should be used for passive objects that carry data, and may have\nassociated constants, but lack any functionality other than access/setting the\ndata members. All fields must be public, and accessed directly rather than\nthrough getter/setter methods. The struct must not have invariants that imply\nrelationships between different fields, since direct user access to those fields\nmay break those invariants. Methods should not provide behavior but should only\nbe used to set up the data members, e.g., constructor, destructor, Initialize(),\nReset()."),(0,r.kt)("p",null,"If more functionality or invariants are required, a class is more appropriate.\nIf in doubt, make it a class."),(0,r.kt)("h5",{id:"inheritance"},"Inheritance"),(0,r.kt)("p",null,"Composition is often more appropriate than inheritance. When using inheritance,\nmake it ",(0,r.kt)("inlineCode",{parentName:"p"},"public"),"."),(0,r.kt)("p",null,"All inheritance should be public. If you want to do private inheritance, you\nshould be including an instance of the base class as a member instead."),(0,r.kt)("p",null,'Do not overuse implementation inheritance. Composition is often more\nappropriate. Try to restrict the use of inheritance to the "is-a" case: Bar\nsubclasses Foo if it can reasonably be said that Bar "is a kind of" Foo.'),(0,r.kt)("h5",{id:"multiple-inheritance"},"Multiple Inheritance"),(0,r.kt)("p",null,'Multiple inheritance is especially problematic, because it often imposes a\nhigher performance overhead (in fact, the performance drop from single\ninheritance to multiple inheritance can often be greater than the performance\ndrop from ordinary to virtual dispatch), and because it risks leading to\n"diamond" inheritance patterns, which are prone to ambiguity, confusion, and\noutright bugs.'),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Multiple implementation inheritance is strongly discouraged.")),(0,r.kt)("h5",{id:"move"},"move"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"std::move")," introduced in C++11 can effectively transfer resources to other\nobjects. In our practice, use ",(0,r.kt)("inlineCode",{parentName:"p"},"std :: move")," can effectively reduce the\nconsumption of ",(0,r.kt)("inlineCode",{parentName:"p"},"Gas"),", especially when using containers. When returning a value,\nit should return rvalue references and use ",(0,r.kt)("inlineCode",{parentName:"p"},"std::move")," to convert lvalue\nreferences to rvalue references to reduce Gas consumption. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"std::vector<std::string>&& get_vec() {\n    std::vector<std::string> v;\n    // ignore\n    return std::move(v); // very important\n}\n")),(0,r.kt)("h4",{id:"auto"},"auto"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"auto")," keyword can automatically deduced from its initializer. Used with\ncontainers and iterators can simplify code. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"std::map<std::string, std::string> my_map;\nfor (auto it = my_map.begin(); it != my_map.end(); it++) {\n    // ignore\n}\n")),(0,r.kt)("h5",{id:"reference-arguments"},"Reference Arguments"),(0,r.kt)("p",null,"Suggest using reference arguments as function parameters. Reference parameters\ncan reduce unnecessary replication and reduce unnecessary memory allocation. For us\nWASM virtual machines, memory allocation is an expensive operation."),(0,r.kt)("h5",{id:"containers"},"Containers"),(0,r.kt)("p",null,"The C ++ standard library provides some commonly used containers (map, vector, list, etc.), and you should carefully read the corresponding interface documentation when using it. It is important to note that the ",(0,r.kt)("inlineCode",{parentName:"p"},"operator[]")," oper ator of map, according to the interface documentation, when the key does not exist, the insert action will be performed. For contract development, when using ",(0,r.kt)("inlineCode",{parentName:"p"},"StorageType")," to store the map, do not use",(0,r.kt)("inlineCode",{parentName:"p"},"operator []"),"to determine whether the key exists, but use",(0,r.kt)("inlineCode",{parentName:"p"},"find ()")," ."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"api"},"API"),(0,r.kt)("h3",{id:"block-api"},"block api"),(0,r.kt)("h4",{id:"platon_block_hash"},"platon_block_hash()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"h256 platon::platon_block_hash(int64_t num)\n")),(0,r.kt)("p",null,"Gets the block hash based on the block height."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"num:")," Height of block"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Hash of block")))),(0,r.kt)("h4",{id:"platon_block_number"},"platon_block_number()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"uint64_t platon_block_number()\n")),(0,r.kt)("p",null,"Get the height of the current block"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the height of the current block")))),(0,r.kt)("h4",{id:"platon_coinbase"},"platon_coinbase()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"Address platon::platon_coinbase()\n")),(0,r.kt)("p",null,"Gets the Hash of miner nodes."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Hash of miner nodes")))),(0,r.kt)("h4",{id:"platon_unix_timestamp"},"platon_unix_timestamp()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int64_t platon::platon_unix_timestamp()\n")),(0,r.kt)("p",null,"Get the unix timestamp of the current block."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The unix timestamp of the current block (second)")))),(0,r.kt)("h4",{id:"platon_gas_limit"},"platon_gas_limit()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"uint64_t platon_gas_limit()\n")),(0,r.kt)("p",null,"Get the value of gas price limit"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the value of gas price limit")))),(0,r.kt)("h3",{id:"transaction-api"},"transaction api"),(0,r.kt)("h4",{id:"platon_gas_price"},"platon_gas_price()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"u128 platon::platon_gas_price()\n")),(0,r.kt)("p",null,"Get the value of gas price."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The value of gas price")))),(0,r.kt)("h4",{id:"platon_gas"},"platon_gas()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"uint64_t platon_gas()\n")),(0,r.kt)("p",null,"Get the value of gas"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the value of gas")))),(0,r.kt)("h4",{id:"platon_caller_nonce"},"platon_caller_nonce"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"uint64_t platon_caller_nonce()\n")),(0,r.kt)("p",null,"Get the value of the caller's nonce"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the value of the caller's nonce")))),(0,r.kt)("h4",{id:"platon_call_value"},"platon_call_value()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"u128 platon::platon_call_value()\n")),(0,r.kt)("p",null,"Get the value of the current transaction value field."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The value of the current transaction value field")))),(0,r.kt)("h4",{id:"platon_caller"},"platon_caller()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"Address platon::platon_caller()\n")),(0,r.kt)("p",null,"Get the address of caller."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The address of caller")))),(0,r.kt)("h4",{id:"platon_origin"},"platon_origin()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"Address platon::platon_origin()\n")),(0,r.kt)("p",null,"Get the address of original caller."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The address of original caller")))),(0,r.kt)("h4",{id:"platon_address"},"platon_address()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"Address platon::platon_address()\n")),(0,r.kt)("p",null,"Get the address of contract."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The address of contract")))),(0,r.kt)("h3",{id:"account-api"},"account api"),(0,r.kt)("h4",{id:"make_address-12"},"make_address() 1/2"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template <size_t M> std::pair<Address, bool> make_address(const char (&str)[M])\n")),(0,r.kt)("p",null,"The default address recognized by CDT is the main network address, that is, the address prefix is atp. "),(0,r.kt)("p",null,"Converts a c-style string to an address object."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"str\uff1a")," C-style string"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The return value is pair, whose second represents success or failure, and whose first represents an Address of type Address.")))),(0,r.kt)("h4",{id:"make_address-22"},"make_address() 2/2"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"std::pair<Address, bool> make_address(const std::string &str_address)\n")),(0,r.kt)("p",null,"The default address recognized by CDT is the main network address, that is, the address prefix is atp. If you want to recognize the test network address prefix is lat, you need to define the macro TESTNET, and you can put #define TESTNET on the first line of the contract."),(0,r.kt)("p",null,"Converts a string to an address object."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"str\uff1a")," string"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The return value is pair, whose second represents success or failure, and whose first represents an Address of type Address.")))),(0,r.kt)("h4",{id:"platon_balance"},"platon_balance()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"Energon platon::platon_balance(const Address & addr)\n")),(0,r.kt)("p",null,"Get the balance based on the address."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," address"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The balance of the address")))),(0,r.kt)("h4",{id:"platon_transfer"},"platon_transfer()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"bool platon::platon_transfer(const Address &addr, const Energon &amount)\n")),(0,r.kt)("p",null,"Transfer the amount of Energon to address."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Accounts address"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"amount:")," The amount of Energon"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"true if transfer success, false otherwise")))),(0,r.kt)("h4",{id:"platonenergon-class"},"platon::Energon Class"),(0,r.kt)("p",null,"Energo is a type of currency"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Public Member Functions")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Energon (u128 n)"),"\nConstruct a new Energon.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const u128 Get () const"),"\nGet amount of Von.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const bytes Bytes () const"),"\nGet the bytes of value, the bytes use big-end representations.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Energon & Add (const u128 &v)"),"\nAdd amount of Von.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Energon & Add (const Energon &rhs)"),"\nAdd amount of Von.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Energon & operator+= (const Energon &rhs)"),"\nImplement operator +=")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Constructor & Destructor Documentation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"platon::Energon::Energon(u128 n)"),"\nConstruct a new Energon.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"n:"),"amount of Von"))))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Member Function Documentation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Energon& platon::Energon::Add(const Energon & rhs)"),"\nAdd amount of Von."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"rhs:"),"Amount of Von"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The reference of Energon"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Energon& platon::Energon::Add(const u128 & v)"),"\nAdd amount of Von."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"v:")," Amount of Von"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The reference of Energon"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const bytes platon::Energon::Bytes() const")),(0,r.kt)("p",{parentName:"li"},"Get the bytes of value, the bytes use big-end representations."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The bytes of value"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const u128 platon::Energon::Get() const")),(0,r.kt)("p",{parentName:"li"},"Get amount of Von."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The amount of Von"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Energon& platon::Energon::operator+= ( const Energon & rhs)")),(0,r.kt)("p",{parentName:"li"},"Implement operator +="),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"rhs:")," Energon object"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The reference of Energon")))))))),(0,r.kt)("h4",{id:"platonwhitelist-tablename--class"},"platon::WhiteList< TableName > Class"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<Name::Raw TableName>\nclass platon::WhiteList< TableName >\n")),(0,r.kt)("p",null,"Persist storage whitelist implement."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Template Parameters"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Name:")," Whitelist name, in the same contract, the name should be unique")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Constructor & Destructor Documentation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName> platon::WhiteList< TableName >::WhiteList ()")),(0,r.kt)("p",{parentName:"li"},"Construct a new whitelist.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"public Member Functions")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"WhiteList ()"),"\nConstruct a new whitelist.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"void Add (const std::string &addr)"),"\nAdd the address to whitelist.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"void Add (const Address &addr)"),"\nAdd the address to whitelist.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"void Delete (const std::string &addr)"),"\nDelete the address from whitelist.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"void Delete (const Address &addr)"),"\nDelete the address from whitelist.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"bool Exists (const std::string &addr)"),"\nWhether the address exists in whitelist.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"bool Exists (const Address &addr)"),"\nWhether the address exists in whitelist.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Member Function Documentation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName> void platon::WhiteList< TableName >::Add ( const Address & addr)")),(0,r.kt)("p",{parentName:"li"},"Add the address to whitelist."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Accounts address"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName> void platon::WhiteList< TableName >::Add ( const std::string & addr)"),"\nAdd the address to whitelist."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Accounts address"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName> void platon::WhiteList< TableName >::Delete ( const Address & addr)"),"\nDelete the address from whitelist."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Accounts address"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName> void platon::WhiteList< TableName >::Delete ( const std::string & addr)"),"\nDelete the address from whitelist."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Accounts address"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName> bool platon::WhiteList< TableName >::Exists ( const Address & addr)"),"\nWhether the address exists in whitelist."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Accounts address"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"true if exists, false otherwise"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName> bool platon::WhiteList< TableName >::Exists ( const std::string & addr)"),"\nWhether the address exists in whitelist."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Accounts address"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"true if exists, false otherwise")))))))),(0,r.kt)("h3",{id:"storage-api"},"storage api"),(0,r.kt)("h4",{id:"platon_set_state"},"platon_set_state()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void platon_set_state(const uint8_t *key, size_t klen, const uint8_t *value, size_t vlen)\n")),(0,r.kt)("p",null,"Set the state object"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"key:")," Key"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Klen:")," The length of key"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value:")," Value"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"vlen:")," The length of value")))),(0,r.kt)("h4",{id:"platon_get_state_length"},"platon_get_state_length()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"size_t platon_get_state_length(const uint8_t *key, size_t klen)\n")),(0,r.kt)("p",null,"Get the length of state object"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")," ","*",(0,r.kt)("inlineCode",{parentName:"p"},"key:")," Key"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Klen:")," The length of key"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The length of state object")))),(0,r.kt)("h4",{id:"platon_get_state"},"platon_get_state()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"size_t platon_get_state(const uint8_t *key, size_t klen, uint8_t *value, size_t vlen);\n")),(0,r.kt)("p",null,"Get the state object"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"key:")," Key"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Klen:")," The length of key"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value:")," Value"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"vlen:")," The length of value"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The length of value")))),(0,r.kt)("h4",{id:"platonstoragetype-storagename-t--class-template"},"platon::StorageType< StorageName, T > Class Template"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<Name::Raw StorageName, typename T>\nclass platon::StorageType< StorageName, T >\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Template Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"StorageName:")," Element value name, in the same contract, the name needs to be unique"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"T:")," Element type"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Public Member Functions")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"StorageType ()"),"\nConstruct a new Storage Type object")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"StorageType (const T &d)"),"\nConstruct a new Storage Type object")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"StorageType (const StorageType< StorageName, T > &)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"StorageType (const StorageType< StorageName, T > &&)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"~StorageType ()"),"\nDestroy the Storage Type object. Refresh to blockchain.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T & operator= (const T &t)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> bool operator== (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> bool operator!= (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> bool operator< (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> bool operator>= (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> bool operator<= (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> bool operator> (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T & operator^= (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T operator^ (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T & operator|= (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T operator| (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T & operator&= (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T operator& (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T operator~ () const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T & operator<< (int offset)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T & operator>> (int offset)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T & operator++ ()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T operator++ (int)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T & operator[] (int i)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T & operator+= (const P &p)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T & operator-= (const P &p)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T & operator* ()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T * operator-> ()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"operator bool () const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T get () const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T & self ()")))))),(0,r.kt)("h4",{id:"platondbarray-tablename-key-n--class-template"},"platon::db::Array< TableName, Key, N > Class Template"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<Name::Raw TableName, typename Key, unsigned N>\nclass platon::db::Array< TableName, Key, N >\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Classes")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"class const_iterator Constant iterator."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"class const_reverse_iterator Constant reverse iterator."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"class iterator Iterator."))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Public Types")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"typedef std::reverse_iterator< iterator > reverse_iterator")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Public Member Functions")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Array ()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Array (const Array< TableName, Key, N > &)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Array (const Array< TableName, Key, N > &&)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Array< TableName, Key, N > & operator= (const Array< TableName, Key, N > &)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"~Array ()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"iterator begin ()"),"\niterator start position")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"iterator end ()"),"\niterator end position")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"reverse_iterator rbegin ()"),"\nReverse iterator start position.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"reverse_iterator rend ()"),"\nReverse iterator end position.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const_iterator cbegin ()"),"\nConstant iterator start position.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const_iterator cend ()"),"\nConstant iterator end position.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const_reverse_iterator crbegin ()"),"\nInverse constant iterator start position.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const_reverse_iterator crend ()"),"\nInverse constant iterator end position.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Key & at (size_t pos)"),"\nGet the specified position element.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Key & operator[] (size_t pos)"),"\nBracket operator.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"size_t size ()"),"\narray size")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Key get_const (size_t pos)"),"\nGet the Const object. Do not flush to cache.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"void set_const (size_t pos, const Key &key)"),"\nSet the Const object, Do not flush to cache.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Static Public Attributes")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},'static const std::string kType = "__array__"'))))),(0,r.kt)("h4",{id:"platondbmap-tablename-key-value--class-template"},"platon::db::Map< TableName, Key, Value > Class Template"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<Name::Raw TableName, typename Key, typename Value>\nclass platon::db::Map< TableName, Key, Value >\n")),(0,r.kt)("p",null,"Implement map operations, Map templates."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Template Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"TableName:")," The name of the Map, the name of the Map should be unique within each contract."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Key:")," key type"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Value:")," value type")),(0,r.kt)("p",{parentName:"li"},"MapType::Traverse The default is Traverse, when Traverse needs extra data structure to operate, set to NoTraverse when no traversal operation is needed.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Public Member Functions")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Map ()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Map(const Map&lt; TableName, Key, Value &gt; &amp;)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Map(const Map&lt; TableName, Key, Value &gt; &amp;&amp;)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Map&lt; TableName, Key, Value &gt; &amp; operator= (const Map&lt; TableName, Key, Value &gt; &amp;)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"~Map ()"),"\nDestroy the Map object Refresh data to the blockchain.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"bool insert (const Key &k, const Value &v)"),"\nInsert a new key-value pair, Update to cache.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"bool insert_const (const Key &k, const Value &v)"),"\nInsert a new key-value pair that will not be updated to the cache. Suitable for large number of inserts, no updates after insertion.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Value get_const (const Key &k)"),"\nGet the Const object, will not join the cache.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Value & at (const Key &k)"),"\nGet value, will be added to the cache.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"void erase (const Key &k)"),"\nDelete key-value pairs.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Value & operator[] (const Key &k)"),"\nBracket operator.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"boolcontains (const Key &key)"),"\nChecks if there is an element with key equivalent to key in the container.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"void flush ()"),"\nRefresh the modified data in memory to the blockchain.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Static Public Attributes"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},'static const std::string kType = "__map__"'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Constructor & Destructor Documentation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value > platon::db::Map< TableName, Key, Value >::Map ()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value > platon::db::Map< TableName, Key, Value >::Map (const Map< TableName, Key, Value > & )"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value > platon::db::Map< TableName, Key, Value >::Map (const Map< TableName, Key, Value > && )"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value > platon::db::Map< TableName, Key, Value >::~Map ()")))))),(0,r.kt)("p",null,"Destroy the Map object Refresh data to the blockchain."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Member Function Documentation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value > Value& platon::db::Map< TableName, Key, Value >::at ( const Key & k )"),"\nGet value, will be added to the cache."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"k:")," Key"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Value&")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'typedef platon::db::Map<"map_str"_n, std::string, std::string> MapStr;\nMapStr map;\nmap.insert("hello", "world");\nassert(map.at["hello"] == "world");\n'))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value > bool platon::db::Map< TableName, Key, Value >::contains ( const Key & key )"),"\nChecks if there is an element with key equivalent to key in the container."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"k:")," Key"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"true if there is such an element, otherwise false.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},' typedef platon::db::Map<"map_str"_n, std::string, std::string> MapStr;\n MapStr map;\n map.["hello"] = "world";\nassert(map.contains("hello"));\n'))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value > void platon::db::Map< TableName, Key, Value >::erase ( const Key & k )"),"\nDelete key-value pairs."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"k:")," Key"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'typedef platon::db::Map<"map_str"_n, std::string, std::string> MapStr;\nMapStr map;\nmap.insert("hello", "world");\nmap.erase("hello");\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value > void platon::db::Map< TableName, Key, Value >::flush ()"),"\nRefresh the modified data in memory to the blockchain.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value > Value platon::db::Map< TableName, Key, Value >::get_const ( const Key & k)"),"\nGet the Const object, will not join the cache."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"k:")," Key"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Value")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'typedef platon::db::Map<"map_str"_n, std::string, std::string> MapStr;\nMapStr map;\nmap.insert("hello", "world");\nassert(map.get_const["hello"] == "world");\n'))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value > bool platon::db::Map< TableName, Key, Value >::insert ( const Key & k, const Value & v)"),"\nInsert a new key-value pair, Update to cache."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"k:")," Key"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"v:")," Value"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"true if insert successfully,false otherwise."))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'typedef platon::db::Map<"map_str"_n, std::string, std::string> MapStr;\nMapStr map;\nmap.insert("hello", "world");\nassert(map["hello"] == "world");\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value > bool platon::db::Map< TableName, Key, Value >::insert_const ( const Key & k, const Value & v)"),"\nInsert a new key-value pair that will not be updated to the cache. Suitable for large number of inserts, no updates after insertion."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"k:")," Key"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"v:")," Value"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"true if insert successfully,false otherwise."))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'typedef platon::db::Map<"map_str"_n, std::string, std::string> MapStr;\nMapStr map;\nmap.insert_const("hello", "world");\nassert(map["hello"] == "world");\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value > Map<TableName, Key, Value>& platon::db::Map< TableName, Key, Value >::operator= ( const Map< TableName, Key, Value > & )"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value > Value& platon::db::Map< TableName, Key, Value >::operator[] ( const Key & k)"),"\nBracket operator."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"k:")," Key"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Value& Get Value")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'typedef platon::db::Map<"map_str"_n, std::string, std::string> MapStr;\nMapStr map;\nmap.["hello"] = "world";\n'))))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Member Data Documentation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},'template<Name::Raw TableName, typename Key , typename Value > const std::string platon::db::Map< TableName, Key, Value >::kType = "__map__"'))))),(0,r.kt)("h4",{id:"templatenameraw-tablename-typename-t-typename-indices-class-platondbmultiindex-tablename-t-indices-"},"template<Name::Raw TableName, typename T, typename... Indices> class platon::db::MultiIndex< TableName, T, Indices >"),(0,r.kt)("p",null,"MultiIndex supports unique indexes and ordinary indexes. The unique index should be placed first in the parameter. The structure needs to provide the get function corresponding to the index field."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Member Function Documentation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices>const_iterator platon::db::MultiIndex< TableName, T, Indices >::cbegin()"),"\nIterator start position"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"const_iterator"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Example:"))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'  struct Member {\n  std::string name;\n  uint8_t age;\n  uint8_t sex;\n  uint64_t $seq_;\n  std::string Name() const { return name; }\n  uint8_t Age() const { return age; }\n  PLATON_SERIALIZE(Member, (name)(age)(sex))\n};\nMultiIndex<\n  "table"_n, Member,\n  IndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                      IndexType::UniqueIndex>>,\n  IndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                      IndexType::NormalIndex>>>\n  member_table;\nfor (auto it = member_table.cbegin(); it != it_end; ++it){}\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices> const_iterator platon::db::MultiIndex< TableName, T, Indices >::cend()"),"\nIterator end position"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"const_iterator"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Example:"))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'  struct Member {\n  std::string name;\n  uint8_t age;\n  uint8_t sex;\n  uint64_t $seq_;\n  std::string Name() const { return name; }\n  uint8_t Age() const { return age; }\n  PLATON_SERIALIZE(Member, (name)(age)(sex))\n};\nMultiIndex<\n  "table"_n, Member,\n  IndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                      IndexType::UniqueIndex>>,\n  IndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                      IndexType::NormalIndex>>>\n  member_table;\nfor (auto it = member_table.cbegin(); it != it_end; ++it){}\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices> template<Name::Raw IndexName, typename KEY > size_t platon::db::MultiIndex< TableName, T, Indices >::count(const KEY &key)")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Gets the number of data corresponding to the index value"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Example:"))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'struct Member {\nstd::string name;\nuint8_t age;\nuint8_t sex;\nuint64_t $seq_;\nstd::string Name() const { return name; }\nuint8_t Age() const { return age; }\nPLATON_SERIALIZE(Member, (name)(age)(sex))\n};\nMultiIndex<\n"table"_n, Member,\n  IndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                    IndexType::UniqueIndex>>,\nIndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                      IndexType::NormalIndex>>>\nmember_table;\nauto count = member_table.count<"index2"_n>(uint8_t(10));\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices> template<typename Lambda> std::pair<const_iterator, bool> platon::db::MultiIndex< TableName, T, Indices >::emplace(Lambda &constructor)")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"constructor of value"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Returns an iterator that indicates whether the insertion was successful with the bool type. If unique index conflicts, the insertion fails"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Example:"))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'struct Member {\n  std::string name;\n  uint8_t age;\n  uint8_t sex;\n  uint64_t $seq_;\n  std::string Name() const { return name; }\n  uint8_t Age() const { return age; }\n  PLATON_SERIALIZE(Member, (name)(age)(sex))\n};\nMultiIndex<\n  "table"_n, Member,\n  IndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                      IndexType::UniqueIndex>>,\n  IndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                      IndexType::NormalIndex>>>\n  member_table;\nmember_table.emplace([&](auto &m) {\n  m.age = 10;\n  m.name = "hello";\n  m.sex = 1;\n});\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices> void platon::db::MultiIndex< TableName, T, Indices >::erase(const_iterator position)"),"\nerase data based on iterator"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"position:")," position of iterator"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Example:"))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'struct Member {\nstd::string name;\nuint8_t age;\nuint8_t sex;\nuint64_t $seq_;\nstd::string Name() const { return name; }\nuint8_t Age() const { return age; }\nPLATON_SERIALIZE(Member, (name)(age)(sex))\n};\nMultiIndex<\n"table"_n, Member,\nIndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                  IndexType::UniqueIndex>>,\nIndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                    IndexType::NormalIndex>>>\nmember_table;\nauto vect_iter = member_table.find<"index2"_n>(uint8_t(10));\nmember_table.erase(vect_iter[0]);\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices> template<Name::Raw IndexName, typename KEY > const_iterator platon::db::MultiIndex< TableName, T, Indices >::find(const KEY & key)"),"\nFind the data, Only a unique index is available."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"key:")," key of index"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the first iterator. cend() if not found."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Example:"))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'struct Member {\nstd::string name;\nuint8_t age;\nuint8_t sex;\nuint64_t $seq_;\nstd::string Name() const { return name; }\nuint8_t Age() const { return age; }\nPLATON_SERIALIZE(Member, (name)(age)(sex))\n};\nMultiIndex<\n"table"_n, Member,\n  IndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                    IndexType::UniqueIndex>>,\nIndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                      IndexType::NormalIndex>>>\nmember_table;\nauto vect_iter = member_table.find<"index2"_n>(uint8_t(10));\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices> template<Name::Raw IndexName>auto platon::db::MultiIndex< TableName, T, Indices >::get_index()"),"\nGets the index object of a non-unique index."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"index object"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Example:"))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'struct Member {\nstd::string name;\nuint8_t age;\nuint8_t sex;\nuint64_t $seq_;\nstd::string Name() const { return name; }\nuint8_t Age() const { return age; }\nPLATON_SERIALIZE(Member, (name)(age)(sex))\n};\nMultiIndex<\n"table"_n, Member,\n  IndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                    IndexType::UniqueIndex>>,\nIndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                      IndexType::NormalIndex>>>\nmember_table;\nauto index = member_table.get_index<"index2"_n>();\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices> template<typename Lambda >void platon::db::MultiIndex< TableName, T, Indices >::modify(const_iterator position,Lambda && constructor)"),"\nModify data based on iterator, but cannot modify all index-related fields ."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"position:")," position of iterator"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"constructor:")," lambda function that updates the target object"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Example:"))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'struct Member {\nstd::string name;\nuint8_t age;\nuint8_t sex;\nuint64_t $seq_;\nstd::string Name() const { return name; }\nuint8_t Age() const { return age; }\nPLATON_SERIALIZE(Member, (name)(age)(sex))\n};\nMultiIndex<\n"table"_n, Member,\n  IndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                    IndexType::UniqueIndex>>,\nIndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                      IndexType::NormalIndex>>>\nmember_table;\nmember_table.modify(r.first, [&](auto &m) { m.sex = 15; });\n')))))),(0,r.kt)("h3",{id:"contract-api"},"contract api"),(0,r.kt)("h4",{id:"platon_destroy"},"platon_destroy()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"bool platon::platon_destroy ( const Address & addr)\n")),(0,r.kt)("p",null,"Destory contract."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Address of the contract"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"true if destroy successfully, false otherwise")))),(0,r.kt)("h4",{id:"platon_migrate_contract"},"platon_migrate_contract()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename value_type , typename gas_type >\nbool platon::platon_migrate_contract ( Address & addr,\nconst bytes & init_args,\nvalue_type  value,\ngas_type  gas)\n")),(0,r.kt)("p",null,"Migrate contract."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," The address of new contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"init_args:")," The input arguments"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value:")," Transfer amount"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"gas:")," Pay amount of gas for this transaction"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"true if migration successfully, false otherwise")))),(0,r.kt)("h4",{id:"cross_call_args"},"cross_call_args()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename... Args>\nbytes platon::cross_call_args ( const std::string & method,\nconst Args &...  args)\n")),(0,r.kt)("p",null,"Construct the Parameters of the call across contracts."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"method:")," The method name of the invoked contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args:")," The Parameters corresponding to the contract method"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Parameter byte array")))),(0,r.kt)("h4",{id:"platon_call-12"},"platon_call() 1/2"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename value_type , typename gas_type >\nbool platon::platon_call ( const Address & addr,\nconst bytes & paras,\nconst value_type & value,\nconst gas_type & gas)\n")),(0,r.kt)("p",null,"Normal cross-contract invocation."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," The contract address to be invoked"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"paras:")," A contract parameter constructed using the function cross_call_args"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"gas:")," The called contract method estimates the gas consumed"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value:")," The amount transferred to the contract"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The call succeed or failed")))),(0,r.kt)("h4",{id:"platon_call-22"},"platon_call() 2/2"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename return_type , typename value_type , typename gas_type , typename... Args>\ndecltype(auto) platon::platon_call ( const Address & addr,\nconst value_type & value,\nconst gas_type & gas,\nconst std::string & method,\nconst Args &...  args\n)\n")),(0,r.kt)("p",null,"Normal cross-contract invocation."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," The contract address to be invoked"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value:")," The amount transferred to the contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"gas:")," The called contract method estimates the gas consumed"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"method:")," The method name of the invoked contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args:")," The Parameters corresponding to the contract method"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The contract method ","*"," ",(0,r.kt)("strong",{parentName:"li"},"Returns")," the value and whether the execution was successful"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'auto result =\nplaton_call<int>(Address("0xEC081ab45BE978A4A630eB8cbcBffA50E747971B"),\nuint32_t(100), uint32_t(100), "add", 1,2,3);\nif(!result.secod){\n  platon_throw("cross call fail");\n}\n')))),(0,r.kt)("h4",{id:"platon_delegate_call-12"},"platon_delegate_call() 1/2"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename gas_type >\nbool platon::platon_delegate_call ( const Address & addr,\nconst bytes & paras,\nconst gas_type & gas\n)\n")),(0,r.kt)("p",null,"Cross contract delegation call."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," The contract address to be invoked"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"paras:")," A contract parameter constructed using the function cross_call_args"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"gas:")," The called contract method estimates the gas consumed"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The call succeed or failed")))),(0,r.kt)("h4",{id:"platon_delegate_call-22"},"platon_delegate_call() 2/2"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename return_type , typename gas_type , typename... Args>\ndecltype(auto) platon::platon_delegate_call ( const Address & addr,\nconst gas_type & gas,\nconst std::string & method,\nconst Args &...  args)\n")),(0,r.kt)("p",null,"The proxy is invoked across contracts."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," The contract address to be invoked"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"gas:")," The called contract method estimates the gas consumed"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"method:")," The method name of the invoked contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args:")," The Parameters corresponding to the contract method"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The contract method ","*"," ",(0,r.kt)("strong",{parentName:"li"},"Returns")," the value and whether the execution was successful"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'auto result =\nplaton_delegate_call<int>(Address("0xEC081ab45BE978A4A630eB8cbcBffA50E747971B"),\n uint32_t(100), "add", 1,2,3);\n if(!result.secod){\n   platon_throw("cross call fail");\n }\n')))),(0,r.kt)("h4",{id:"get_call_output"},"get_call_output()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename T >\nvoid platon::get_call_output ( T & t)\n")),(0,r.kt)("p",null,"Gets the return value of calling contract methods across contracts."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Template Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"T:")," The output value type"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"t:")," The value returned by the contract method")))),(0,r.kt)("h4",{id:"platon_event"},"platon_event"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void platon_event(const uint8_t *topic, size_t topic_len, const uint8_t *args,\n                  size_t args_len);\n")),(0,r.kt)("p",null,"Post event to VM"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"topic:")," The topic of event"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"topic_len:")," The length of topic"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args:")," The arguments"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args_len:")," The length of arguments")))),(0,r.kt)("h3",{id:"exception-api"},"exception api"),(0,r.kt)("h4",{id:"platon_panic"},"platon_panic"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void platon_panic(void);\n")),(0,r.kt)("p",null,"Terminate transaction, deduct all gas given by transaction"),(0,r.kt)("h4",{id:"platon_revert"},"platon_revert"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void platon_revert(void);\n")),(0,r.kt)("p",null,"Terminate the transaction and deduct the gas consumed"),(0,r.kt)("h3",{id:"other-api"},"other api"),(0,r.kt)("h4",{id:"platon_sha3"},"platon_sha3()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"h256 platon::platon_sha3 ( const bytes & data )\n")),(0,r.kt)("p",null,"Sh3 algorithm."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"data:")," Binary data"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The Hash of the data")))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"faq"},"FAQ"),(0,r.kt)("h3",{id:"about-compile"},"About Compile"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"How to use ",(0,r.kt)("inlineCode",{parentName:"p"},"platon-cpp")," for compile multiple ",(0,r.kt)("inlineCode",{parentName:"p"},"cpp")," files?"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"platon-cpp ./test.cpp ./test1.cpp\n")),(0,r.kt)("p",{parentName:"li"},"Only allowing exists one contract class.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"How to specified output directory and filename when use ",(0,r.kt)("inlineCode",{parentName:"p"},"platon-cpp"),"\nto compile contract?"),(0,r.kt)("p",{parentName:"li"},"Use ",(0,r.kt)("inlineCode",{parentName:"p"},"-o")," flag, and must be specified output directory and filename at the\nsame time."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"platon-cpp ./test.cpp -o ./out/test.wasm\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"What data types does ABI support?"),(0,r.kt)("p",{parentName:"li"},"Generate ABI supported types and conversion rules as follows:"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"ABI"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"bool")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uint8_t"),(0,r.kt)("td",{parentName:"tr",align:null},"uint8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uint16_t"),(0,r.kt)("td",{parentName:"tr",align:null},"uint16")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uint32_t"),(0,r.kt)("td",{parentName:"tr",align:null},"uint32")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uint64_t"),(0,r.kt)("td",{parentName:"tr",align:null},"uint64")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"int8_t"),(0,r.kt)("td",{parentName:"tr",align:null},"int8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"int16_t"),(0,r.kt)("td",{parentName:"tr",align:null},"int16")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"int32_t"),(0,r.kt)("td",{parentName:"tr",align:null},"int32")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"int64_t"),(0,r.kt)("td",{parentName:"tr",align:null},"int64")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bytes"),(0,r.kt)("td",{parentName:"tr",align:null},"uint8","[","]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::string"),(0,r.kt)("td",{parentName:"tr",align:null},"string")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::vector","<","T",">"),(0,r.kt)("td",{parentName:"tr",align:null},"T","[","]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::array","[","T, N","]"),(0,r.kt)("td",{parentName:"tr",align:null},"T","[","N","]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::pair","<","T, U",">"),(0,r.kt)("td",{parentName:"tr",align:null},"pair","<","T, U")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::set","<","T",">"),(0,r.kt)("td",{parentName:"tr",align:null},"set","<","T",">")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::map","<","T, V",">"),(0,r.kt)("td",{parentName:"tr",align:null},"map","<","T, V",">")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::list","<","T",">"),(0,r.kt)("td",{parentName:"tr",align:null},"list","<","T",">")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"FixedHash","<","N",">"),(0,r.kt)("td",{parentName:"tr",align:null},"FixedHash","<","N",">")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"u128"),(0,r.kt)("td",{parentName:"tr",align:null},"uint128")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bigint"),(0,r.kt)("td",{parentName:"tr",align:null},"uint128")))),(0,r.kt)("h3",{id:"about-contract"},"About Contract"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"How to output contract debug logs in the ",(0,r.kt)("inlineCode",{parentName:"p"},"platon")," process?"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Add ",(0,r.kt)("inlineCode",{parentName:"p"},"#undef NDEBUG")," at the first line of contract codes, and must before\nheader file included."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#undef NDEBUG\n\n#include <platon/platon.hpp>\n\n//...\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"platon")," startup command specifies log level 4 and enable debug flag."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"./platon --debug --verbosity 4 ...\n"))))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"How to write a contract can effectively reduce Gas consumption?"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Use reference arguments"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void test(const std::string& str) {}\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Return rvalue reference"))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"std::vector<std::string>&& test() {\n    std::vector<std::string> v;\n    // ...\n    return std::move(v);\n}\n")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Try not to apply for large blocks of memory"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"What should I pay attention to when using ",(0,r.kt)("inlineCode",{parentName:"p"},"StorageType"),"?"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Should be initialized in ",(0,r.kt)("inlineCode",{parentName:"li"},"init()"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},' CONTRAT Hello : public Contract {\n public:\n   ACTION void init() {\n       s_.self() = "test";\n   }\n private:\n   StorageType<"test"_n, std::string> s_;\n };\n')))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"\n- It is recommended to use a specialized type of `StorageType` directly\n\n  + Uint8\n  + Int8\n  + Uint16\n  + Int16\n  + Uint\n  + Int\n  + Uint64\n  + Int64\n  + String\n  + Vector\n  + Set\n  + Map\n  + Array\n  + Tuple\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"What is the difference between ",(0,r.kt)("inlineCode",{parentName:"p"},"StorageType")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"platon::db::Map"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"platon::db::Array"),"?"),(0,r.kt)("p",{parentName:"li"},"From the underlying storage level, the implementation of ",(0,r.kt)("inlineCode",{parentName:"p"},"StorageType")," is\nserialized as a whole, and then stored in the database. ",(0,r.kt)("inlineCode",{parentName:"p"},"platon::db::Map"),"\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"platon::db::Array")," serialize each element of the container as K/V is\nstored to the database. For large-scale data, ",(0,r.kt)("inlineCode",{parentName:"p"},"platon::db::Map")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"platon::db::Array")," perform better."),(0,r.kt)("p",{parentName:"li"},"When implementing a contract, a suitable storage structure should be\nselected based on the size of the data.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"RLP serialization/deserialization What C++ standard library types are\nsupported?"),(0,r.kt)("p",{parentName:"li"},"The following C ++ standard library types are supported:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"std::string"),(0,r.kt)("li",{parentName:"ul"},"std::vector"),(0,r.kt)("li",{parentName:"ul"},"std::map"),(0,r.kt)("li",{parentName:"ul"},"std::list"),(0,r.kt)("li",{parentName:"ul"},"std::array"),(0,r.kt)("li",{parentName:"ul"},"std::set"),(0,r.kt)("li",{parentName:"ul"},"std::pair"),(0,r.kt)("li",{parentName:"ul"},"std::tuple"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"How do custom types support RLP serialization/deserialization?"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Macro ",(0,r.kt)("inlineCode",{parentName:"li"},"PLATON_SERIALIZE")," for common types")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"   struct Base {\n   int a;\n   std::string b;\n\n   PLATON_SERIALIZE(Base, (a)(b));\n   };\n")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The derived class uses the macro\xa0",(0,r.kt)("inlineCode",{parentName:"li"},"PLATON_SERIALIZE_DERIVED"),", and the base class also uses the macro\xa0",(0,r.kt)("inlineCode",{parentName:"li"},"PLATON_SERIALIZE"))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Derived : public Base {\n  int c;\n  int d;\n\n  PLATON_SERIALIZE_DERIVED(Derived, Base, (c)(d));\n};\n")))))}d.isMDXComponent=!0}}]);