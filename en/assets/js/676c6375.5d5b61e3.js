(self.webpackChunkalaya_docs=self.webpackChunkalaya_docs||[]).push([[7967],{3905:function(e,t,a){"use strict";a.d(t,{Zo:function(){return s},kt:function(){return d}});var n=a(7294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function p(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var m=n.createContext({}),o=function(e){var t=n.useContext(m),a=t;return e&&(a="function"==typeof e?e(t):p(p({},t),e)),a},s=function(e){var t=o(e.components);return n.createElement(m.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},k=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,r=e.originalType,m=e.parentName,s=i(e,["components","mdxType","originalType","parentName"]),k=o(a),d=l,N=k["".concat(m,".").concat(d)]||k[d]||u[d]||r;return a?n.createElement(N,p(p({ref:t},s),{},{components:a})):n.createElement(N,p({ref:t},s))}));function d(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=a.length,p=new Array(r);p[0]=k;var i={};for(var m in t)hasOwnProperty.call(t,m)&&(i[m]=t[m]);i.originalType=e,i.mdxType="string"==typeof e?e:l,p[1]=i;for(var o=2;o<r;o++)p[o]=a[o];return n.createElement.apply(null,p)}return n.createElement.apply(null,a)}k.displayName="MDXCreateElement"},7242:function(e,t,a){"use strict";a.r(t),a.d(t,{frontMatter:function(){return p},contentTitle:function(){return i},metadata:function(){return m},toc:function(){return o},default:function(){return u}});var n=a(2122),l=a(9756),r=(a(7294),a(3905)),p={id:"Wasm_API",title:"Wasm API",sidebar_label:"Wasm API"},i=void 0,m={unversionedId:"Wasm_API",id:"Wasm_API",isDocsHomePage:!1,title:"Wasm API",description:"Block API",source:"@site/docs/Wasm_API.md",sourceDirName:".",slug:"/Wasm_API",permalink:"/alaya-devdocs/en/Wasm_API",editUrl:"https://github.com/AlayaNetwork/alaya-devdocs/tree/main/website/docs/Wasm_API.md",version:"current",frontMatter:{id:"Wasm_API",title:"Wasm API",sidebar_label:"Wasm API"},sidebar:"docs",previous:{title:"Best practices",permalink:"/alaya-devdocs/en/Wasm_Best_practices"},next:{title:"JS SDK",permalink:"/alaya-devdocs/en/JS_SDK"}},o=[{value:"Block API",id:"block-api",children:[{value:"platon_block_hash()",id:"platon_block_hash",children:[]},{value:"platon_block_number()",id:"platon_block_number",children:[]},{value:"platon_coinbase()",id:"platon_coinbase",children:[]},{value:"platon_unix_timestamp()",id:"platon_unix_timestamp",children:[]},{value:"platon_gas_limit()",id:"platon_gas_limit",children:[]}]},{value:"Transaction API",id:"transaction-api",children:[{value:"platon_gas_price()",id:"platon_gas_price",children:[]},{value:"platon_gas()",id:"platon_gas",children:[]},{value:"platon_caller_nonce",id:"platon_caller_nonce",children:[]},{value:"platon_call_value()",id:"platon_call_value",children:[]},{value:"platon_caller()",id:"platon_caller",children:[]},{value:"platon_origin()",id:"platon_origin",children:[]},{value:"platon_address()",id:"platon_address",children:[]}]},{value:"Account API",id:"account-api",children:[{value:"make_address() 1/2",id:"make_address-12",children:[]},{value:"make_address() 2/2",id:"make_address-22",children:[]},{value:"platon_balance()",id:"platon_balance",children:[]},{value:"platon_transfer()",id:"platon_transfer",children:[]},{value:"platon::Energon Class",id:"platonenergon-class",children:[]},{value:"platon::WhiteList&lt; TableName &gt; Class",id:"platonwhitelist-tablename--class",children:[]}]},{value:"Storage API",id:"storage-api",children:[{value:"platon_set_state()",id:"platon_set_state",children:[]},{value:"platon_get_state_length()",id:"platon_get_state_length",children:[]},{value:"platon_get_state()",id:"platon_get_state",children:[]},{value:"platon::StorageType&lt; StorageName, T &gt; Class Template",id:"platonstoragetype-storagename-t--class-template",children:[]},{value:"platon::db::Array&lt; TableName, Key, N &gt; Class Template",id:"platondbarray-tablename-key-n--class-template",children:[]},{value:"platon::db::Map&lt; TableName, Key, Value &gt; Class Template",id:"platondbmap-tablename-key-value--class-template",children:[]},{value:"template&lt;Name::Raw TableName, typename T, typename... Indices&gt; class platon::db::MultiIndex&lt; TableName, T, Indices &gt;",id:"templatenameraw-tablename-typename-t-typename-indices-class-platondbmultiindex-tablename-t-indices-",children:[]}]},{value:"Contract API",id:"contract-api",children:[{value:"platon_destroy()",id:"platon_destroy",children:[]},{value:"platon_migrate_contract()",id:"platon_migrate_contract",children:[]},{value:"cross_call_args()",id:"cross_call_args",children:[]},{value:"platon_call() 1/2",id:"platon_call-12",children:[]},{value:"platon_call() 2/2",id:"platon_call-22",children:[]},{value:"platon_delegate_call() 1/2",id:"platon_delegate_call-12",children:[]},{value:"platon_delegate_call() 2/2",id:"platon_delegate_call-22",children:[]},{value:"get_call_output()",id:"get_call_output",children:[]},{value:"platon_event()",id:"platon_event",children:[]}]},{value:"Exception API",id:"exception-api",children:[{value:"platon_panic()",id:"platon_panic",children:[]},{value:"platon_revert()",id:"platon_revert",children:[]}]},{value:"Other API",id:"other-api",children:[{value:"platon_sha3()",id:"platon_sha3",children:[]}]}],s={toc:o};function u(e){var t=e.components,a=(0,l.Z)(e,["components"]);return(0,r.kt)("wrapper",(0,n.Z)({},s,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"block-api"},"Block API"),(0,r.kt)("h3",{id:"platon_block_hash"},"platon_block_hash()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"h256 platon::platon_block_hash(int64_t num)\n")),(0,r.kt)("p",null,"Get the block hash based on the block height."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"num:")," Height of block"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Hash of block.")))),(0,r.kt)("h3",{id:"platon_block_number"},"platon_block_number()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"uint64_t platon_block_number()\n")),(0,r.kt)("p",null,"Get the height of the current block"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The height of the current block.")))),(0,r.kt)("h3",{id:"platon_coinbase"},"platon_coinbase()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"Address platon::platon_coinbase()\n")),(0,r.kt)("p",null,"Gets the Hash of miner nodes."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Hash of miner nodes.")))),(0,r.kt)("h3",{id:"platon_unix_timestamp"},"platon_unix_timestamp()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int64_t platon::platon_unix_timestamp()\n")),(0,r.kt)("p",null,"Get the unix timestamp of the current block."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The unix timestamp of the current block (second).")))),(0,r.kt)("h3",{id:"platon_gas_limit"},"platon_gas_limit()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"uint64_t platon_gas_limit()\n")),(0,r.kt)("p",null,"Get the value of gas price limit."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The value of gas price limit.")))),(0,r.kt)("h2",{id:"transaction-api"},"Transaction API"),(0,r.kt)("h3",{id:"platon_gas_price"},"platon_gas_price()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"u128 platon::platon_gas_price()\n")),(0,r.kt)("p",null,"Get the gas price of the transaction."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The gas price of the transaction.")))),(0,r.kt)("h3",{id:"platon_gas"},"platon_gas()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"uint64_t platon_gas()\n")),(0,r.kt)("p",null,"Get the gas value of the transaction."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The value of gas.")))),(0,r.kt)("h3",{id:"platon_caller_nonce"},"platon_caller_nonce"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"uint64_t platon_caller_nonce()\n")),(0,r.kt)("p",null,"Get the value of the caller's nonce."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The value of the caller's nonce.")))),(0,r.kt)("h3",{id:"platon_call_value"},"platon_call_value()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"u128 platon::platon_call_value()\n")),(0,r.kt)("p",null,"Get the value of the current transaction value field."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The value of the current transaction value field.")))),(0,r.kt)("h3",{id:"platon_caller"},"platon_caller()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"Address platon::platon_caller()\n")),(0,r.kt)("p",null,"Get the address of caller."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The address of caller.")))),(0,r.kt)("h3",{id:"platon_origin"},"platon_origin()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"Address platon::platon_origin()\n")),(0,r.kt)("p",null,"Get the address of original caller."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The address of original caller.")))),(0,r.kt)("h3",{id:"platon_address"},"platon_address()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"Address platon::platon_address()\n")),(0,r.kt)("p",null,"Get the address of contract."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The address of contract.")))),(0,r.kt)("h2",{id:"account-api"},"Account API"),(0,r.kt)("h3",{id:"make_address-12"},"make_address() 1/2"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template <size_t M> std::pair<Address, bool> make_address(const char (&str)[M])\n")),(0,r.kt)("p",null,"By default, the address recognized by CDT is the mainnet address, that is, the address prefix is atp. If you want to recognize the test network address prefix as atx, you need to define the macro TESTNET, and add #define TESTNET to the first line of the contract."),(0,r.kt)("p",null,"Convert a c-style string to an address object."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"str\uff1a")," C-style string"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The return value is pair, whose second represents success or failure, and whose first represents an Address of type Address.")))),(0,r.kt)("h3",{id:"make_address-22"},"make_address() 2/2"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"std::pair<Address, bool> make_address(const std::string &str_address)\n")),(0,r.kt)("p",null,"By default, the address recognized by CDT is the mainnet address, that is, the address prefix is atp. If you want to recognize the test network address prefix as atx, you need to define the macro TESTNET, and add #define TESTNET to the first line of the contract."),(0,r.kt)("p",null,"Converts a string to an address object."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"str\uff1a")," string"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The return value is pair, whose second represents success or failure, and whose first represents an Address of type Address.")))),(0,r.kt)("h3",{id:"platon_balance"},"platon_balance()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"Energon platon::platon_balance(const Address & addr)\n")),(0,r.kt)("p",null,"Get the balance based on the address."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," address"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The balance of the address.")))),(0,r.kt)("h3",{id:"platon_transfer"},"platon_transfer()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"bool platon::platon_transfer(const Address &addr, const Energon &amount)\n")),(0,r.kt)("p",null,"Transfer the amount of Energon to address."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Accounts address"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"amount:")," The amount of Energon"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"True if transfer succeeds, or false otherwise.")))),(0,r.kt)("h3",{id:"platonenergon-class"},"platon::Energon Class"),(0,r.kt)("p",null,"Energo is a currency-related operation class"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Public Member Functions")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Energon (u128 n)"),"\nConstruct a new Energon.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const u128 Get () const"),"\nGet a certain amount of Von.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const bytes Bytes () const"),"\nGet the bytes of value. The bytes use big-end representations.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Energon & Add (const u128 &v)"),"\nAdd a certain amount of Von.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Energon & Add (const Energon &rhs)"),"\nAdd two Energon objects")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Energon & operator+= (const Energon &rhs)"),"\nImplement operator +=")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Constructor & Destructor Documentation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"platon::Energon::Energon(u128 n)"),"\nConstruct a new Energon.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"n:"),"Amount of Von"))))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Member Function Documentation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Energon& platon::Energon::Add(const Energon & rhs)"),"\nAdd a certain amount of Von."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"rhs:"),"Amount of Von"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The reference of Energon."))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Energon& platon::Energon::Add(const u128 & v)"),"\nAdd a certain amount of Von."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"v:")," Amount of Von"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The reference of Energon."))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const bytes platon::Energon::Bytes() const")),(0,r.kt)("p",{parentName:"li"},"Get the bytes of value. The bytes use big-end representations."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The bytes of value."))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const u128 platon::Energon::Get() const")),(0,r.kt)("p",{parentName:"li"},"Get a certain amount of Von."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The amount of Von."))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Energon& platon::Energon::operator+= ( const Energon & rhs)")),(0,r.kt)("p",{parentName:"li"},"Implement operator +="),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"rhs:")," Energon object"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The reference of Energon.")))))))),(0,r.kt)("h3",{id:"platonwhitelist-tablename--class"},"platon::WhiteList< TableName > Class"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<Name::Raw TableName>\nclass platon::WhiteList< TableName >\n")),(0,r.kt)("p",null,"A tool to persistently store the whitelist."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Template Parameters"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Name:")," Whitelist name. The name should be unique in the same contract")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Constructor & Destructor Documentation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName> platon::WhiteList< TableName >::WhiteList ()")),(0,r.kt)("p",{parentName:"li"},"Construct a new whitelist.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"public Member Functions")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"WhiteList ()"),"\nConstruct a new whitelist.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"void Add (const std::string &addr)"),"\nAdd the address to whitelist.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"void Add (const Address &addr)"),"\nAdd the address to whitelist.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"void Delete (const std::string &addr)"),"\nDelete the address from whitelist.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"void Delete (const Address &addr)"),"\nDelete the address from whitelist.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"bool Exists (const std::string &addr)"),"\nWhether the address exists in whitelist.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"bool Exists (const Address &addr)"),"\nWhether the address exists in whitelist.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Member Function Documentation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName> void platon::WhiteList< TableName >::Add ( const Address & addr)")),(0,r.kt)("p",{parentName:"li"},"Add the address to whitelist."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Accounts address"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName> void platon::WhiteList< TableName >::Add ( const std::string & addr)"),"\nAdd the address to whitelist."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Accounts address"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName> void platon::WhiteList< TableName >::Delete ( const Address & addr)"),"\nDelete the address from whitelist."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Accounts address"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName> void platon::WhiteList< TableName >::Delete ( const std::string & addr)"),"\nDelete the address from whitelist."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Accounts address"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName> bool platon::WhiteList< TableName >::Exists ( const Address & addr)"),"\nWhether the address exists in whitelist."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Accounts address"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"True if it exists, or false otherwise"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName> bool platon::WhiteList< TableName >::Exists ( const std::string & addr)"),"\nWhether the address exists in whitelist."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Accounts address"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"True if it exists, or false otherwise.")))))))),(0,r.kt)("h2",{id:"storage-api"},"Storage API"),(0,r.kt)("h3",{id:"platon_set_state"},"platon_set_state()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void platon_set_state(const uint8_t *key, size_t klen, const uint8_t *value, size_t vlen)\n")),(0,r.kt)("p",null,"Set the state object."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"key:")," Key"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Klen:")," The length of key"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value:")," Value"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"vlen:")," The length of value")))),(0,r.kt)("h3",{id:"platon_get_state_length"},"platon_get_state_length()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"size_t platon_get_state_length(const uint8_t *key, size_t klen)\n")),(0,r.kt)("p",null,"Get the length of the value corresponding to the key."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")," ","*",(0,r.kt)("inlineCode",{parentName:"p"},"key:")," Key"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Klen:")," The length of key"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The length of state object.")))),(0,r.kt)("h3",{id:"platon_get_state"},"platon_get_state()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"size_t platon_get_state(const uint8_t *key, size_t klen, uint8_t *value, size_t vlen);\n")),(0,r.kt)("p",null,"Get the state object."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"key:")," Key"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Klen:")," The length of key"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value:")," Value"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"vlen:")," The length of value"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The length of value.")))),(0,r.kt)("h3",{id:"platonstoragetype-storagename-t--class-template"},"platon::StorageType< StorageName, T > Class Template"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<Name::Raw StorageName, typename T>\nclass platon::StorageType< StorageName, T >\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Template Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"StorageName:")," Element value name. The name needs to be unique in the same contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"T:")," Element type"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Public Member Functions")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"StorageType ()"),"\nConstruct a new Storage Type object")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"StorageType (const T &d)"),"\nConstruct a new Storage Type object")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"StorageType (const StorageType< StorageName, T > &)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"StorageType (const StorageType< StorageName, T > &&)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"~StorageType ()"),"\nDestroy the Storage Type object. Refresh to blockchain.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T & operator= (const T &t)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> bool operator== (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> bool operator!= (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> bool operator< (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> bool operator>= (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> bool operator<= (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> bool operator> (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T & operator^= (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T operator^ (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T & operator|= (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T operator| (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T & operator&= (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T operator& (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T operator~ () const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T & operator<< (int offset)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T & operator>> (int offset)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T & operator++ ()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T operator++ (int)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T & operator[] (int i)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T & operator+= (const P &p)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T & operator-= (const P &p)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T & operator* ()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T * operator-> ()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"operator bool () const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T get () const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T & self ()")))))),(0,r.kt)("h3",{id:"platondbarray-tablename-key-n--class-template"},"platon::db::Array< TableName, Key, N > Class Template"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<Name::Raw TableName, typename Key, unsigned N>\nclass platon::db::Array< TableName, Key, N >\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Classes")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"class const_iterator Constant iterator."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"class const_reverse_iterator Constant reverse iterator."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"class iterator Iterator."))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Public Types")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"typedef std::reverse_iterator< iterator > reverse_iterator")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Public Member Functions")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Array ()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Array (const Array< TableName, Key, N > &)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Array (const Array< TableName, Key, N > &&)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Array< TableName, Key, N > & operator= (const Array< TableName, Key, N > &)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"~Array ()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"iterator begin ()"),"\nStart position of iterator")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"iterator end ()"),"\nEnd position of iterator")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"reverse_iterator rbegin ()"),"\nStart position of reverse iterator.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"reverse_iterator rend ()"),"\nEnd position of reverse iterator.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const_iterator cbegin ()"),"\nStart position of constant iterator.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const_iterator cend ()"),"\nEnd position of inverse constant iterator.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const_reverse_iterator crbegin ()"),"\nStart position of inverse constant iterator.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const_reverse_iterator crend ()"),"\nEnd position of inverse constant iterator.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Key & at (size_t pos)"),"\nGet the specified position element.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Key & operator[] (size_t pos)"),"\nBracket operator.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"size_t size ()"),"\narray size")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Key get_const (size_t pos)"),"\nGet the Const object. Do not flush to cache.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"void set_const (size_t pos, const Key &key)"),"\nSet the Const object, Do not flush to cache.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Static Public Attributes")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},'static const std::string kType = "__array__"'))))),(0,r.kt)("h3",{id:"platondbmap-tablename-key-value--class-template"},"platon::db::Map< TableName, Key, Value > Class Template"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<Name::Raw TableName, typename Key, typename Value>\nclass platon::db::Map< TableName, Key, Value >\n")),(0,r.kt)("p",null,"Implement map operations, Map templates."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Template Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"TableName:")," The name of the Map. The name of the Map should be unique within each contract."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Key:")," key type"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Value:")," value type")),(0,r.kt)("p",{parentName:"li"},"MapType::Traverse The default is Traverse, when Traverse needs extra data structure to operate, set to NoTraverse when no traversal operation is needed.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Public Member Functions")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Map ()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Map(const Map&lt; TableName, Key, Value &gt; &amp;)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Map(const Map&lt; TableName, Key, Value &gt; &amp;&amp;)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Map&lt; TableName, Key, Value &gt; &amp; operator= (const Map&lt; TableName, Key, Value &gt; &amp;)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"~Map ()"),"\nDestroy the Map object Refresh data to the blockchain.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"bool insert (const Key &k, const Value &v)"),"\nInsert a new key-value pair, Update to cache.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"bool insert_const (const Key &k, const Value &v)"),"\nThe insert will not update the new key-value pair to the cache. It is suitable for a large number of inserts, with no need to update after inserting.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Value get_const (const Key &k)"),"\nGet the Const object, will not join the cache.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Value & at (const Key &k)"),"\nGet value, will be added to the cache.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"void erase (const Key &k)"),"\nDelete key-value pairs.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Value & operator[] (const Key &k)"),"\nBracket operator.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"boolcontains (const Key &key)"),"\nChecks if there is an element with key equivalent to key in the container.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"void flush ()"),"\nRefresh the modified data in memory to the blockchain.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Static Public Attributes")),(0,r.kt)("p",{parentName:"li"},"  ",(0,r.kt)("inlineCode",{parentName:"p"},'static const std::string kType = "__map__"'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Constructor & Destructor Documentation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value > platon::db::Map< TableName, Key, Value >::Map ()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value > platon::db::Map< TableName, Key, Value >::Map (const Map< TableName, Key, Value > & )"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value > platon::db::Map< TableName, Key, Value >::Map (const Map< TableName, Key, Value > && )"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value > platon::db::Map< TableName, Key, Value >::~Map ()")))))),(0,r.kt)("p",null,"Destroy the Map object, and refresh the data to the blockchain."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Member Function Documentation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value > Value& platon::db::Map< TableName, Key, Value >::at ( const Key & k )"),"\nGet value, will be added to the cache."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"k:")," Key"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Value&"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'typedef platon::db::Map<"map_str"_n, std::string, std::string> MapStr;\nMapStr map;\nmap.insert("hello", "world");\nassert(map.at["hello"] == "world");\n'))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value > bool platon::db::Map< TableName, Key, Value >::contains ( const Key & key )"),"\nChecks if there is an element with key equivalent to key in the container."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"k:")," Key"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"True if there is such an element; otherwise false."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},' typedef platon::db::Map<"map_str"_n, std::string, std::string> MapStr;\n MapStr map;\n map.["hello"] = "world";\nassert(map.contains("hello"));\n'))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value > void platon::db::Map< TableName, Key, Value >::erase ( const Key & k )"),"\nDelete key-value pairs."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"k:")," Key"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'   typedef platon::db::Map<"map_str"_n, std::string, std::string> MapStr;\n   MapStr map;\n   map.insert("hello", "world");\n   map.erase("hello");\n')))))))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'- `template<Name::Raw TableName, typename Key , typename Value > void platon::db::Map< TableName, Key, Value >::flush ()`\n  Refresh the modified data in memory to the blockchain.\n\n- `template<Name::Raw TableName, typename Key , typename Value > Value platon::db::Map< TableName, Key, Value >::get_const ( const Key & k)`\n  Get the Const object, will not join the cache.\n\n    - **Parameters**\n\n        - `k:` Key\n\n    - **Returns**\n\n        - Value\n    - **Example:**\n\n      ```cpp\n      typedef platon::db::Map<"map_str"_n, std::string, std::string> MapStr;\n      MapStr map;\n      map.insert("hello", "world");\n      assert(map.get_const["hello"] == "world");\n      ```\n\n- `template<Name::Raw TableName, typename Key , typename Value > bool platon::db::Map< TableName, Key, Value >::insert ( const Key & k, const Value & v)`\n  Insert a new key-value pair, Update to cache.\n\n    - **Parameters**\n\n        - `k:` Key\n\n        - `v:` Value\n    - **Returns**\n\n        - True if inserted successfully, or false otherwise.\n\n    - **Example:**\n\n      ```cpp\n      typedef platon::db::Map<"map_str"_n, std::string, std::string> MapStr;\n      MapStr map;\n      map.insert("hello", "world");\n      assert(map["hello"] == "world");\n      ```\n\n- `template<Name::Raw TableName, typename Key , typename Value > bool platon::db::Map< TableName, Key, Value >::insert_const ( const Key & k, const Value & v)`\n  The insert will not update the new key-value pair to the cache. It is suitable for a large number of inserts, with no need to update after insertion.\n\n    - **Parameters**\n\n        - `k:` Key\n\n        - `v:` Value\n    - **Returns**\n\n        - True if inserted successfully, or false otherwise.\n\n    - **Example:**\n\n      ```cpp\n      typedef platon::db::Map<"map_str"_n, std::string, std::string> MapStr;\n      MapStr map;\n      map.insert_const("hello", "world");\n      assert(map["hello"] == "world");\n      ```\n\n- `template<Name::Raw TableName, typename Key , typename Value > Map<TableName, Key, Value>& platon::db::Map< TableName, Key, Value >::operator= ( const Map< TableName, Key, Value > & )`\n\n- `template<Name::Raw TableName, typename Key , typename Value > Value& platon::db::Map< TableName, Key, Value >::operator[] ( const Key & k)`\n  Bracket operator.\n\n    - **Parameters**\n\n        - `k:` Key\n\n    - **Returns**\n\n        - Value& Get Value.\n    - **Example:**\n\n      ```cpp\n      typedef platon::db::Map<"map_str"_n, std::string, std::string> MapStr;\n      MapStr map;\n      map.["hello"] = "world";\n      ```\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Member Data Documentation"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},'template<Name::Raw TableName, typename Key , typename Value > const std::string platon::db::Map< TableName, Key, Value >::kType = "__map__"'))))),(0,r.kt)("h3",{id:"templatenameraw-tablename-typename-t-typename-indices-class-platondbmultiindex-tablename-t-indices-"},"template<Name::Raw TableName, typename T, typename... Indices> class platon::db::MultiIndex< TableName, T, Indices >"),(0,r.kt)("p",null,"MultiIndex supports unique indexes and ordinary indexes. The unique index should be placed first in the parameter. The structure needs to provide the get function corresponding to the index field."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Member Function Documentation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices>const_iterator platon::db::MultiIndex< TableName, T, Indices >::cbegin()")),(0,r.kt)("p",{parentName:"li"},"Start iterator"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"const_iterator."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Example:"))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'  struct Member {\n  std::string name;\n  uint8_t age;\n  uint8_t sex;\n  uint64_t $seq_;\n  std::string Name() const { return name; }\n  uint8_t Age() const { return age; }\n  PLATON_SERIALIZE(Member, (name)(age)(sex))\n};\nMultiIndex<\n  "table"_n, Member,\n  IndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                      IndexType::UniqueIndex>>,\n  IndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                      IndexType::NormalIndex>>>\n  member_table;\nfor (auto it = member_table.cbegin(); it != it_end; ++it){}\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices> const_iterator platon::db::MultiIndex< TableName, T, Indices >::cend()")),(0,r.kt)("p",{parentName:"li"},"End iterator"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"const_iterator."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'  struct Member {\n  std::string name;\n  uint8_t age;\n  uint8_t sex;\n  uint64_t $seq_;\n  std::string Name() const { return name; }\n  uint8_t Age() const { return age; }\n  PLATON_SERIALIZE(Member, (name)(age)(sex))\n};\nMultiIndex<\n  "table"_n, Member,\n  IndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                      IndexType::UniqueIndex>>,\n  IndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                      IndexType::NormalIndex>>>\n  member_table;\nfor (auto it = member_table.cbegin(); it != it_end; ++it){}\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices> template<Name::Raw IndexName, typename KEY > size_t platon::db::MultiIndex< TableName, T, Indices >::count(const KEY &key)")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Gets the number of data corresponding to the index value."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Example:"))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'struct Member {\nstd::string name;\nuint8_t age;\nuint8_t sex;\nuint64_t $seq_;\nstd::string Name() const { return name; }\nuint8_t Age() const { return age; }\nPLATON_SERIALIZE(Member, (name)(age)(sex))\n};\nMultiIndex<\n"table"_n, Member,\n  IndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                    IndexType::UniqueIndex>>,\nIndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                      IndexType::NormalIndex>>>\nmember_table;\nauto count = member_table.count<"index2"_n>(uint8_t(10));\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices> template<typename Lambda> std::pair<const_iterator, bool> platon::db::MultiIndex< TableName, T, Indices >::emplace(Lambda &constructor)")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Data item processing function"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Returns an iterator that indicates whether the insertion was successful with the bool type. If unique index conflicts, the insertion fails."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Example:"))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'struct Member {\n  std::string name;\n  uint8_t age;\n  uint8_t sex;\n  uint64_t $seq_;\n  std::string Name() const { return name; }\n  uint8_t Age() const { return age; }\n  PLATON_SERIALIZE(Member, (name)(age)(sex))\n};\nMultiIndex<\n  "table"_n, Member,\n  IndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                      IndexType::UniqueIndex>>,\n  IndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                      IndexType::NormalIndex>>>\n  member_table;\nmember_table.emplace([&](auto &m) {\n  m.age = 10;\n  m.name = "hello";\n  m.sex = 1;\n});\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices> void platon::db::MultiIndex< TableName, T, Indices >::erase(const_iterator position)"),"\nErase data based on iterator"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"position:")," position of iterator"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Example:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},' struct Member {\n std::string name;\n uint8_t age;\n uint8_t sex;\n uint64_t $seq_;\n std::string Name() const { return name; }\n uint8_t Age() const { return age; }\n PLATON_SERIALIZE(Member, (name)(age)(sex))\n };\n MultiIndex<\n "table"_n, Member,\n IndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                 IndexType::UniqueIndex>>,\n IndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                   IndexType::NormalIndex>>>\n member_table;\n auto vect_iter = member_table.find<"index"_n>(std::string("use to find data"));\n member_table.erase(vect_iter[0]);\n'))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices> template<Name::Raw IndexName, typename KEY > const_iterator platon::db::MultiIndex< TableName, T, Indices >::find(const KEY & key)"),(0,r.kt)("br",{parentName:"p"}),"\n","Find the data, Only a unique index is available."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"key:")," key of index"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The result iterator. If not found, the value is cend()."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Example:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},' struct Member {\n std::string name;\n uint8_t age;\n uint8_t sex;\n uint64_t $seq_;\n std::string Name() const { return name; }\n uint8_t Age() const { return age; }\n PLATON_SERIALIZE(Member, (name)(age)(sex))\n };\n MultiIndex<\n "table"_n, Member,\n IndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                   IndexType::UniqueIndex>>,\n IndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                     IndexType::NormalIndex>>>\n member_table;\n auto vect_iter = member_table.find<"index"_n>(std::string("use to find data"));\n'))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices> template<Name::Raw IndexName>auto platon::db::MultiIndex< TableName, T, Indices >::get_index()"),"\nGet the index object of a non-unique index."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"index object."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Example:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},' struct Member {\n std::string name;\n uint8_t age;\n uint8_t sex;\n uint64_t $seq_;\n std::string Name() const { return name; }\n uint8_t Age() const { return age; }\n PLATON_SERIALIZE(Member, (name)(age)(sex))\n };\n MultiIndex<\n "table"_n, Member,\n IndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                   IndexType::UniqueIndex>>,\n IndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                      IndexType::NormalIndex>>>\n member_table;\n auto index = member_table.get_index<"index2"_n>();\n'))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices> template<typename Lambda >void platon::db::MultiIndex< TableName, T, Indices >::modify(const_iterator position,Lambda && constructor)"),"\nModify data based on iterators, but not all fields related to the index."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"position:")," Iterator"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"constructor:")," lambda function that updates the target object"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Example:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},' struct Member {\n std::string name;\n uint8_t age;\n uint8_t sex;\n uint64_t $seq_;\n std::string Name() const { return name; }\n uint8_t Age() const { return age; }\n PLATON_SERIALIZE(Member, (name)(age)(sex))\n };\n MultiIndex<\n "table"_n, Member,\n IndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                  IndexType::UniqueIndex>>,\n IndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                    IndexType::NormalIndex>>>\n member_table;\n member_table.modify(r.first, [&](auto &m) { m.sex = 15; });\n')))))))),(0,r.kt)("h2",{id:"contract-api"},"Contract API"),(0,r.kt)("h3",{id:"platon_destroy"},"platon_destroy()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"bool platon::platon_destroy ( const Address & addr)\n")),(0,r.kt)("p",null,"Destroy the contract."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Address of the contract"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"True if the contract is destroyed successfully, or false otherwise.")))),(0,r.kt)("h3",{id:"platon_migrate_contract"},"platon_migrate_contract()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename value_type , typename gas_type >\nbool platon::platon_migrate_contract ( Address & addr,\nconst bytes & init_args,\nvalue_type  value,\ngas_type  gas)\n")),(0,r.kt)("p",null,"Migrate the contract."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," The address of new contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"init_args:")," The input arguments"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value:")," Transfer amount"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"gas:")," Pay amount of gas for this transaction"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"True if the contract is migrated successfully, or false otherwise.")))),(0,r.kt)("h3",{id:"cross_call_args"},"cross_call_args()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename... Args>\nbytes platon::cross_call_args ( const std::string & method,\nconst Args &...  args)\n")),(0,r.kt)("p",null,"Construct cross-contract call parameters."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"method:")," The method name of the called contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args:")," The parameters corresponding to the contract method"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Parameter byte array")))),(0,r.kt)("h3",{id:"platon_call-12"},"platon_call() 1/2"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename value_type , typename gas_type >\nbool platon::platon_call ( const Address & addr,\nconst bytes & paras,\nconst value_type & value,\nconst gas_type & gas)\n")),(0,r.kt)("p",null,"Normal cross-contract call."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," The contract address to be called"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"paras:")," A contract parameter constructed using the function cross_call_args"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"gas:")," The estimated gas consumed by the corresponding contract method"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value:")," The amount transferred to the contract"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The call succeed or failed.")))),(0,r.kt)("h3",{id:"platon_call-22"},"platon_call() 2/2"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename return_type , typename value_type , typename gas_type , typename... Args>\ndecltype(auto) platon::platon_call ( const Address & addr,\nconst value_type & value,\nconst gas_type & gas,\nconst std::string & method,\nconst Args &...  args\n)\n")),(0,r.kt)("p",null,"Normal cross-contract call."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," The contract address to be called"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value:")," The amount transferred to the contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"gas:")," The estimated gas consumed by the corresponding contract method"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"method:")," The method name of the called contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args:")," The parameters corresponding to the contract method"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The contract method ","*"," ",(0,r.kt)("strong",{parentName:"li"},"Returns")," and whether the execution was successful."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'auto result =\nplaton_call<int>(Address("0xEC081ab45BE978A4A630eB8cbcBffA50E747971B"),\nuint32_t(100), uint32_t(100), "add", 1,2,3);\nif(!result.secod){\n  platon_throw("cross call fail");\n}\n')))),(0,r.kt)("h3",{id:"platon_delegate_call-12"},"platon_delegate_call() 1/2"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename gas_type >\nbool platon::platon_delegate_call ( const Address & addr,\nconst bytes & paras,\nconst gas_type & gas\n)\n")),(0,r.kt)("p",null,"Cross-contract proxy call."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," The contract address to be called"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"paras:")," A contract parameter constructed using the function cross_call_args"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"gas:")," The estimated gas consumed by the corresponding contract method"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The call succeed or failed.")))),(0,r.kt)("h3",{id:"platon_delegate_call-22"},"platon_delegate_call() 2/2"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename return_type , typename gas_type , typename... Args>\ndecltype(auto) platon::platon_delegate_call ( const Address & addr,\nconst gas_type & gas,\nconst std::string & method,\nconst Args &...  args)\n")),(0,r.kt)("p",null,"Cross-contract proxy call."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," The contract address to be called"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"gas:")," The estimated gas consumed by the corresponding contract method"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"method:")," The method name of the called contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args:")," The parameters corresponding to the contract method"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The contract method ","*"," ",(0,r.kt)("strong",{parentName:"li"},"Returns")," the value and whether the execution was successful"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'auto result =\nplaton_delegate_call<int>(Address("0xEC081ab45BE978A4A630eB8cbcBffA50E747971B"),\n uint32_t(100), "add", 1,2,3);\n if(!result.secod){\n   platon_throw("cross call fail");\n }\n')))),(0,r.kt)("h3",{id:"get_call_output"},"get_call_output()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename T >\nvoid platon::get_call_output ( T & t)\n")),(0,r.kt)("p",null,"Get the return value of the cross-contract method of calling contract."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Template Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"T:")," The output value type"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"t:")," The value returned by the contract method")))),(0,r.kt)("h3",{id:"platon_event"},"platon_event()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void platon_event(const uint8_t *topic, size_t topic_len, const uint8_t *args,\n                  size_t args_len);\n")),(0,r.kt)("p",null,"Post event to VM"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"topic:")," The topic of event"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"topic_len:")," The length of topic"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args:")," The arguments"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args_len:")," The length of arguments")))),(0,r.kt)("h2",{id:"exception-api"},"Exception API"),(0,r.kt)("h3",{id:"platon_panic"},"platon_panic()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void platon_panic(void);\n")),(0,r.kt)("p",null,"Terminate transaction, and deduct all gas of the transaction"),(0,r.kt)("h3",{id:"platon_revert"},"platon_revert()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void platon_revert(void);\n")),(0,r.kt)("p",null,"Terminate the transaction and deduct the gas consumed"),(0,r.kt)("h2",{id:"other-api"},"Other API"),(0,r.kt)("h3",{id:"platon_sha3"},"platon_sha3()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"h256 platon::platon_sha3 ( const bytes & data )\n")),(0,r.kt)("p",null,"Sh3 algorithm."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"data:")," Binary data"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The Hash of the data")))))}u.isMDXComponent=!0}}]);